#pragma TextEncoding = "UTF-8"#pragma rtGlobals=1		// Use modern global access method.Menu "Analysis"	"-"	Submenu "Jesper's tools"		"Show panel",Make_JT_Panel()		help = {"Make a panel that shows all the commands in this menu as buttons."}		"Show misc panel",Make_JT_Misc_Panel()		help = {"Make a panel that shows all the commands in the miscellanous submenu as buttons."}				"Close all open windows",JT_CloseAllWindows()		help = {"Close all open windows."}				"Top window to top left corner",JT_TopWindowTopLeft()		help = {"Move the top window to top left corner of the screen -- good for relocating windows outside the screen."}				"-"		"Wave list",JT_wList()		help = {"Wavelist of top window."}				"Edit waves in top graph",JT_EditTopGraphWaves()		help = {"Takes all traces in top graph and makes a table containing them."}				"Expand top graph",JT_ExpandTopGraph()		help = {"Takes top graph and changes its expansion factor up or down."}				"Clipboard row to column",JT_row2col()		help = {"Take row data in clipboard and make it into a column of data. With shift button held, do the inverse."}		"Invert trace order",JT_InvertTraceOrder()		help = {"Invert order of traces in top window."}		"Remove axes",RemoveAxes()		help = {"Remove axes in top graph."}		"Add axes",AddAxes()		help = {"Add axes in top graph."}		"Smooth graph",NewSmoothedGraph()		help = {"Make new graph with smoothed traces found in top graph."}		Submenu "Make blue"			"... and white",MakeBlueWhite()			help = {"Prepare top graph for PowerPoint presentation by making background blue and traces white."}			"... and color",MakeBlueCol()			help = {"Prepare top graph for PowerPoint presentation by making background blue and traces in color."}		end		"Align baseline at zero",AlignBaselineAtZero()		help = {"Align baselines as indicated by cursors A and B."}		"Align baseline at mean",AlignBaselineAtMean()		help = {"Align baselines as indicated by cursors A and B."}		"Make average",ProduceMeanTrace()		help = {"Take all traces in top graph and make average."}		Submenu "Colorize traces"					"Preset oscilloscope colors",CallColorizeTraces1()			help = {"Colorize traces in top graph."}				"Publication colors",CallColorizeTraces6()			help = {"Colorize traces in top graph."}				"Red to blue",CallColorizeTraces2()			help = {"Colorize traces in top graph."}				"Blue to red",CallColorizeTraces4()			help = {"Colorize traces in top graph."}				"Red to green",CallColorizeTraces3()			help = {"Colorize traces in top graph."}			"Green to red",CallColorizeTraces5()			help = {"Colorize traces in top graph."}		end		"Smart Y axis range",SmartYAxisRange()		help = {"Set Y axis to cover entire data range found along the current X axis."}		"Find rise times",FindRiseTimes()		help = {"Find EPSP rise times in traces in top  graph."}				"Copy axes ranges",CopyAxesRanges()		help = {"Take axes ranges from next-to-top graph and copy them to the top graph."}				"Copy cursor positions",CopyCursorPositions()		help = {"Take cursor positions from next-to-top graph and copy them to the top graph."}		"Produce calibrator",ProduceCalibrator()		help = {"Produce calibrator. Use Shift and Caps Lock keys to decrease/increase Y axis bar size. Use Command/Option to alter the X axis bar size."}				"Font: Helvetica",FontIsHelvetica()		help = {"Set the Default Font to Helvetica. Immediately affects all open windows."}				"Remove stim artifacts",MakeStimArtifactPanel()		help = {"Brings up a panel that helps you remove stimulus artifacts in electrophysiology traces."}		"Gamma correction",JT_gammaCorrectionPanel()		help = {"Brings up a panel that helps you gamma-correct a color LUT."}				"Spread traces in graph",JT_SpreadTracesInGraph()		help = {"Takes top graph and spreads traces apart so that you can look at the individual traces more easily."}				"Collect trace names",JT_GatherTraceNames()		help = {"Takes cursor A in top graph and adds the name of the trace it is on to the string {JT_traces}."}				"Duplicate graph",JT_DuplicateGraph()		help = {"Takes top graph and duplicates it."}				"Set line thickness",JT_SetLineThickness()		help = {"Takes top graph and changes the line thickness of all traces."}				"Save all waves in top graph",SaveAllWavesInTopWindow()		help = {"Saves all waves in top graph."}				"Load TIFF header",JT_LoadTIFFheader()		help = {"Load TIFF header from a TIFF file."}		"Tidy command window",JT_TidyCommandWin()		help = {"Moves command window to a reasonable position."}		Submenu "Misc"					"Calculate frequency",JT_CalcFreq()			help = {"Put cursors A & B on trace in graph to calculate the frequency."}			"Get input resistance from MP_DatAn",R_in()			help = {"Dump values from previous run of MP_DatAn."}			"Get V_m or I_hold from MP_DatAn",V_m()			help = {"Dump values from previous run of MP_DatAn."}			"Fit PSP or PSC with AP @ 30 ms",FitEPSP(30)			help = {"Hold shift button to fit negative response."}			"Fit PSP or PSC with AP @ 10 ms",FitEPSP(10)			help = {"Hold shift button to fit negative response."}			"Send JT_Traces list to a graph",ListToGraph(JT_Traces)			help = {"Hold shift button to add traces to top graph."}			"Do Student's T test",JT_PrintDoTTest()			help = {"This choice puts an executable text string that you paste into the command window. Then change the wave names as needed."}			"Modify font size in graph",JT_Mod_fSize()			help = {"Shift makes font size 12, command makes it 18, wheras neither makes it 14."}			"Extract data from STP analysis",JT_ExtractSTPData()			help = {"For PurkPurk paper."}		end	end	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close all open windows -- use with caution!Function JT_CloseAllWindows()	string windowName	PauseUpdate	DoAlert/T="Are you sure?" 1, "Are you sure you want to close all windows?"	if (V_flag==1)		print "--- Closing all graphs"		do			printf "*"			windowName=WinName(0,7)										// Close all graphs, tables, layouts			if (cmpstr(windowName, "")==0)				break			endif			doWindow /K $windowName		while (1)		print "\r"		ResumeUpdate	else		print "--- Not closing any graph"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Perform t-test that is automatically adjusted for equal/unequal variances.Function CorrectedStatTTest(w1,w2)	wave	w1	wave	w2		Variable	p,pf,testType////	This is how it was done in Igor 5	//	pf = 2*Imag(StatFTest(w1,w2))//	if (pf<0.05)//		testType = 1//	else//		testType = 0//	endif////	p = Imag(StatTTest(testType,w1,w2))//// The Igor 6 way of doing it, fixed 3 May 2007, J.Sj.	StatsFTest/Q/Z w1,w2	WAVE/Z	W_StatsFTest	pf = W_StatsFTest[11]	if (pf<0.05)//		StatsTTest/Q/Z/T=1/DFM=0 w1,w2		StatsTTest/Q/Z/DFM=0 w1,w2		WAVE/Z	W_StatsTTest		p = W_StatsTTest[9]//		print "\t\tCorrectedStatTTest reports: p = ",p," -- Unequal variances (",pf,")"	else		StatsTTest/Q/Z/DFM=2 w1,w2  //   // Add /T=1 to show table		WAVE/Z	W_StatsTTest		p = W_StatsTTest[9]//		print "\t\tCorrectedStatTTest reports: p = ",p," -- Equal variances (",pf,")"	endif		Return p	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// JT_detrend removes a linear trend in the top trace of the top graph. Only use with one trace in top graph.//// Start and end point are based on x-axis v_min and v_max.Function JT_detrend()	String		Name = WinName(0,1)	String		TraceList = TraceNameList(Name,";",1)	String		currStr = StringFromList(0,TraceList)	print "Detrending \""+currStr+"\" from top graph \""+Name+"\" by fitting a line."	print "through first and last point on x-axis."	GetAxis bottom	Variable	x1 = V_min	Variable	x2 = V_max	WAVE		w = $(currStr)	Variable	y1 = w(x1)	Variable	y2 = w(x2)	Variable	k = (y2-y1)/(x2-x1)	Variable	m = y2-k*x2		// y = kx+m	Duplicate/O w,JT_tempW,$(currStr+"_DT")	WAVE		w_DT = $(currStr+"_DT")	JT_tempW = k*x+m	w_DT = w-JT_tempW	AppendToGraph/W=$(Name) $(currStr+"_DT")	ModifyGraph RGB($(currStr+"_DT"))=(0,0,0)End/////////////////////////////////////////////////////////////////////////////////////////////////////////Function JT_getSpikes(theLevel,theWave)	Variable	theLevel	WAVE		theWave	FindLevels/DEST=spikeUp/EDGE=1/Q theWave, theLevel	FindLevels/DEST=spikeDown/EDGE=2/Q theWave, theLevel	Duplicate/O spikeUp,thresholdWave,widthWave	thresholdWave = theLevel	widthWave = spikeDown-spikeUp	SetScale d,0,0,"s",widthWave		Variable	n = numpnts(spikeUp)	print "Found "+num2str(n)+" spikes."		DoWindow/K spikesGraph	Display theWave	nw("spikesGraph")	AppendToGraph/W=spikesGraph thresholdWave vs spikeUp	AppendToGraph/W=spikesGraph thresholdWave vs spikeDown	ModifyGraph mode(thresholdWave)=3,mode(thresholdWave#1)=3	ModifyGraph marker(thresholdWave)=20	ModifyGraph rgb(thresholdWave)=(0,0,0)	ModifyGraph marker(thresholdWave#1)=21,rgb(thresholdWave#1)=(0,0,0)	Legend "\s("+NameOfWave(theWave)+") "+NameOfWave(theWave)	DoWindow/K spikeWidthGraph	Display widthWave	nw("spikeWidthGraph")	label bottom,"spike #"	ModifyGraph mode=4,marker=8,opaque=1		JT_ArrangeGraphs2("spikesGraph;spikeWidthGraph;",3,2)		WaveStats/Q widthWave	print "Average spike width:",V_avg*1e3,"±",V_SEM*1e3,"ms"		n = numpnts(widthWave)	String		scrapStr = ""	Variable	i	i = 0	do		scrapStr += num2str(widthWave[i])+"\r"				i += 1	while(i<n)	PutScrapText scrapStr	print "All spike widths are on the clip board."EndFunction sigT()	NVAR		FFT_detAmp	WAVE		pow_total		WaveStats/Q	pow_total	print "Detection threshold",FFT_detAmp	print "SD",V_SDev	print "Threshold in terms of sigma:",FFT_detAmp/V_SDevEndFunction k2angle() // Remember to re-run Mean2 CV analysis between conditions!	WAVE		k_ValueWave = mean2kValueWave	WAVE		ChangeNormWave		Duplicate/O k_ValueWave,AngleWave	AngleWave = (atan(k_ValueWave)-pi/4)/pi*180	AngleWave = ChangeNormWave[p] > 1 ? 180-AngleWave[p] : AngleWave[p]		JT_RemoveNANs(AngleWave)		WaveStats/Q AngleWave	print V_avg,"±",V_sdev/sqrt(V_npnts),"n=",V_npnts		StatsTTest/MEAN=0 AngleWave		Duplicate/O AngleWave,zeroWave	zeroWave = 0	StatsWilcoxonRankTest/ALPH=0.05/TAIL=4 AngleWave,zeroWave	EndFunction JT_ExtractSTPData()	WAVE		PeakNormAmp	NVAR		Freq = root:STPAn:Freq	Variable	i		Variable	n = numpnts(PeakNormAmp)	Variable	PPP,STD	PPP = PeakNormAmp[1]/PeakNormAmp[0]	if (n>2)		STD = Mean(PeakNormAmp,2,n-1)/PeakNormAmp[0]	else		STD = NaN	endif	print "The following data is on the clipboard (freq, PPP, STD):"	print Freq,PPP,STD	PutScrapText  num2str(Freq)+"\t"+num2str(PPP)+"\t"+num2str(STD)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// JT_ScatterXSpread//// For a bar graph with y axis scattered data superposed, you may want to systematically spread the x axis data points//// so that no points overlap. Here, wY is the data, which is plotted versus wX. The size of symbols is denoted by //// diameter. The scaling of the x axis relative to the y axis is given by aspectRatio, so that aspectRatio = 0.5 puts//// data points closer together along the x axis, whereas aspectRatio = 1 spreads them.///////////////////////////////////////////////////////////////////////////////////////////////////////////// JT_autoScatterXSpread//// Calculates aspect ratio automatically.Function JT_autoScatterXSpread(wX,wY)	WAVE		wX	WAVE		wY		String		GraphList = WinList("*",";","WIN:1")	String		NameTop = StringFromList(0,GraphList)	Print		"Working on "+NameTop	doUpdate	GetAxis/Q	left	Variable	yMin = V_min	Variable	yMax = V_max	GetAxis/Q	bottom	Variable	xMin = V_min	Variable	xMax = V_max	SetAxis		left,yMin,yMax	SetAxis		bottom,xMin,xMax	Variable	yAxisSpan = abs(yMax-yMin)	Variable	xAxisSpan = abs(xMax-xMin)		GetWindow $NameTop,psize	Variable	yPixelSpan = abs(V_bottom-V_top)	Variable	xPixelSpan = abs(V_right-V_left)	Variable	aspectRatio = (yPixelSpan/yAxisSpan)/(xPixelSpan/xAxisSpan)	Variable	markerSize = NumberByKey("msize(x)", TraceInfo(NameTop, NameOfWave(wY),0),"=")	if (markerSize == 0)		print "Set marker size to something other than auto!"		Abort "Set marker size to something other than auto!"	endif	Variable	diameter = 2*markerSize*yAxisSpan/yPixelSpan		JT_ScatterXSpread(wX,wY,diameter,aspectRatio)EndFunction JT_ScatterXSpread(wX,wY,diameter,aspectRatio)	WAVE		wX	WAVE		wY	Variable	diameter	Variable	aspectRatio		// y/x		if (diameter<=0)		print "Diameter has to be positive and larger than zero."		Abort "Diameter has to be positive and larger than zero."	endif		Make/O/N=(1)	JT_wScatterX,JT_wScatterY		Variable	n = numpnts(wX)	Variable	i,j,k,theSign	Variable	stepSize = diameter*aspectRatio/100	Variable	currY	Variable	currX	Variable	badPosition	Variable	dX,dY	// First data point is always positioned correctly, in the center	i = 1	JT_wScatterX[0] = 0	JT_wScatterY[0] = wY[0]	theSign = 1	do		currY = wY[i]		j = 0		do			currX = theSign*stepSize*j			k = 0			badPosition = 0			do				dX = abs((currX-JT_wScatterX[k])/aspectRatio)				dY = abs(currY-JT_wScatterY[k])				if (sqrt(dX^2+dY^2)<diameter)					badPosition = 1					k = Inf				endif				k += 1			while (k<numpnts(JT_wScatterY))			theSign *= -1			j += 1		while (badPosition)		JT_wScatterX[numpnts(JT_wScatterX)] = {currX}		JT_wScatterY[numpnts(JT_wScatterY)] = {currY}		i += 1	while(i<n)		Duplicate/O JT_wScatterX,$(NameOfWave(wX))End////////////////////////////////////////////////////////////////////////////////////	Expand top graphFunction JT_ExpandTopGraph()	String		GraphList = WinList("*",";","WIN:1")	String		NameTop = StringFromList(0,GraphList)	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	else		Print "Expand top graph: "+NameTop	endif		Variable	expVal = 2	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means back to normal."		expVal = 1	endif	if (Keys & 2^1)		Print "\tYou pressed the Option key. Instead of 2, use 3 as value."		expVal = 3	endif	if (Keys & 2^0)		Print "\tYou pressed the Command key. Reduce by same amount instead."		expVal = 1/expVal	endif	ModifyGraph/W=$(NameTop) expand=expValEnd////////////////////////////////////////////////////////////////////////////////////	This function returns a string representing a number padded with zeros, so that the number of character//	= digits. If num occupies more digits than requested, the excess low digits of the number are truncated. // 	e.g. calling JT_num2digstr (3,1234) returns "123", while  calling JT_num2digstr (6,1234) returns "001234"// Borrowed from SNUtilities2.3 on 2004-03-08, Jesper SjostromFunction /S JT_num2digstr(digits,num)	variable digits, num	String outstr, zerostr="000000000000", numstr = num2istr(num)	variable i=1		if (strlen(numstr) <= digits) 		outstr = zerostr[0,digits-1]				outstr[digits-strlen(numstr),digits-1] = numstr	else		outstr = numstr[0,digits-1]	endif		return outstrEnd///////////////////////////////////////////////////////////////////////////////////////// Return number with chosen number of decimal placesFunction JT_selDecimals(theNum,theDec)	Variable	theNum	Variable	theDec		theDec = floor(theDec)		Variable	NumWithDecimals		if (theDec<0)		NumWithDecimals = theNum	else		NumWithDecimals = Round(theNum*10^theDec)/10^theDec	endif		Return	NumWithDecimalsEnd////////////////////////////////////////////////////////////////////////////////////// Convert a row of data in clipboard to a column of dataFunction JT_row2col()	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means column to row."		JT_doCol2row()	else		Print "\tRow to column."		JT_doRow2col()	endifEndFunction JT_doRow2col()	String	clipBoard = GetScrapText()		Variable	n = strlen(clipBoard)	Variable	i	i = 0	do		if (StringMatch(clipBoard[i,i],"\t"))			clipBoard[i,i] = "\r"		endif		i += 1	while(i<n)		PutScrapText clipBoardEndFunction JT_doCol2row()	String	clipBoard = GetScrapText()		Variable	n = strlen(clipBoard)	Variable	i	i = 0	do		if (StringMatch(clipBoard[i,i],"\r"))			clipBoard[i,i] = "\t"		endif		i += 1	while(i<n)	PutScrapText clipBoardEnd////////////////////////////////////////////////////////////////////////////////////// Simulate a simple progress bar windowFunction JT_MakeProgressBar(TheValue,TheText)	Variable	TheValue	String		TheText	Variable	debugFlag = 0	if (theValue == -101)		debugFlag = 1	endif	Variable	Width = 320	Variable	rowHeight = 20+4	Variable	Height = 4+rowHeight*2	JT_GetScreenSize()	NVAR	JT_ScreenWidth	NVAR	JT_ScreenHeight	Variable	xPos = JT_ScreenWidth/2-Width/2	Variable	yPos = JT_ScreenHeight/2-Height/2			String/G	JT_Progress_MessageStr = TheText	Variable/G	JT_Progress_val = TheValue		Variable	ScSc = PanelResolution("")/ScreenResolution	Variable frameStyle = 0		if (JT_thisIsWindows())		frameStyle = 2	else	endif	JT_KillProgressBar()	NewPanel/FLT=(1-debugFlag)/W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width,yPos*ScSc+Height)/k=1	DoWindow/C JT_ProgressWin	ModifyPanel cbRGB=(65534,65534,65534)	ValDisplay theBar,pos={4,4+rowHeight*0},size={Width-4-4,rowHeight-4},title="Progress: "	ValDisplay theBar,labelBack=(65535,65535,65535),fSize=12,frame=(frameStyle)	ValDisplay theBar,limits={0,1,0},barmisc={0,0},mode= 3,value=#"root:JT_Progress_val"	SetVariable theText,pos={4,4+rowHeight*1},size={Width-4-4,rowHeight-4},title=" "	SetVariable theText,labelBack=(65535,65535,65535),fSize=12,frame=0	SetVariable theText,noedit= 1,bodyWidth=(Width-4-4),value=root:JT_Progress_MessageStr	DoUpdate/W=JT_ProgressWin/E=1	if (!(debugFlag))		SetActiveSubwindow _endfloat_	endifEndFunction JT_KillProgressBar()	DoWindow JT_ProgressWin	if (V_flag)		DoWindow/K/W=JT_ProgressWin JT_ProgressWin	endifEndFunction JT_UpdateProgressBar(TheValue,TheText)	Variable		TheValue	String		TheText	SVAR		JT_Progress_MessageStr	NVAR		JT_Progress_val	JT_Progress_val = TheValue	JT_Progress_MessageStr = TheText	DoUpdate/W=JT_ProgressWin/E=1End////////////////////////////////////////////////////////////////////////////////////// Duplicate waves in supplied list to waves with supplied suffixFunction JT_DuplicateList(theList,theSuffix)	String		theList	String		theSuffix	String		currName	String/G	JT_NewList = ""	Variable	n = ItemsInList(theList,",")	print "Found",n,"items in list."	Variable	i	Print "Making new list:"	i = 0	do		currName = StringFromList(i,theList,",")		print "\tWorking on #"+num2str(i)+":",currName		Duplicate/O $currName,$(currName+theSuffix)		JT_NewList += currName+theSuffix+","		i += 1	while(i<n)	print "Output list is {JT_NewList}:"	JT_NewList = JT_NewList[0,StrLen(JT_NewList)-2]	print JT_NewListend////////////////////////////////////////////////////////////////////////////////////// Add a Gaussian to the top graphFunction JT_PrintAddGaussian()	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Top graph \""+NameTop+"\" should contain a histogram or the equivalent."	Print "Use JT_AddGaussian(inData) to add Gaussian. This function wants inData to be the data used to generate the histogram in \""+NameTop+"\"."	Print "This function call is now in the clipboard, ready to be pasted into the command line."	PutScrapText "JT_AddGaussian(inData)"EndFunction JT_AddGaussian(inData)	WAVE		inData	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	GetAxis/Q	bottom	Variable	xMin = V_min	Variable	xMax = V_max	GetAxis/Q	left	Variable	yMin = V_min	Variable	yMax = V_max	Variable	nPoints = 500	Variable	amp = yMax-yMin		Make/O/N=(nPoints) Gaussian_fit	SetScale/I x xMin,xMax,"", Gaussian_fit	WaveStats/Q inData	Gaussian_fit = amp*exp(-((x-V_avg)/(V_sdev))^2)	String		traceList = WaveList("Gaussian_fit",";","WIN:")	if (StrLen(traceList)==0)		AppendToGraph Gaussian_fit		ModifyGraph lstyle(Gaussian_fit)=11,rgb(Gaussian_fit)=(0,0,65535)		ModifyGraph lsize(Gaussian_fit)=2		Print "Added trace \"Gaussian_fit\" to top graph called \""+NameTop+"\"."		Print "Now use rename or duplicate if you wish to add more gaussians to the same graph."	else		Print "Trace \"Gaussian_fit\"is already on graph -- not appending it."	endifEnd////////////////////////////////////////////////////////////////////////////////////// Apply a formula to items in listFunction JT_ApplyFormulaToList(theList,theFormula)	String		theList	String		theFormula	String		currName	String/G	JT_NewList = ""	Variable	n = ItemsInList(theList,",")	print "Found",n,"items in list."	print "Applying this formula:\t\ttheListItem",theFormula	Variable	i	i = 0	do		currName = StringFromList(i,theList,",")		print "\tWorking on #"+num2str(i)+":",currName		WAVE w = $currName		Execute currName+theFormula		i += 1	while(i<n)	print "Done"end////////////////////////////////////////////////////////////////////////////////////// Change the font size of the top graphFunction JT_Mod_fSize()	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Changing font size in this graph:",NameTop	DoWindow/F $NameTop	Variable	fontSize = 14	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means smaller font."		fontSize = 12	endif	if (Keys & 2^0)		Print "\tYou pressed the Command key. This means larger font."		fontSize = 18	endif	Print "Font size is now:",fontSize	ModifyGraph fSize = (fontSize)End////////////////////////////////////////////////////////////////////////////////////// Calculate frequency from csrA and csrB in a tracFunction JT_CountCrossings()	GetAxis/Q bottom	Variable	x1 = V_min	Variable	x2 = V_max	String		TraceStr	String	cursorInfo = csrInfo(A)	if (StrLen(cursorInfo)==0)		Beep		Print "Cursor A is not on a trace!"		Abort "Cursor A is not on a trace!"	endif	TraceStr = StringByKey("TNAME",cursorInfo)	print "Working on",TraceStr	WAVE	w = $TraceStr	Duplicate/O w,tempW	Smooth/B 7,tempW		FindLevels/EDGE=1/Q/R=(x1,x2)/M=0.005 tempW,vcsr(A)	print "Found",V_LevelsFound,"upward crossings."End////////////////////////////////////////////////////////////////////////////////////// Calculate frequency from csrA and csrB in a tracFunction JT_CalcFreq()	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means manual frequency detection."		print "Cursor A:",xcsr(A)		print "Cursor B:",xcsr(A)		print "The frequency:",1/abs(xcsr(A)-xcsr(B)),"Hz"	else		JT_FindSpikeFreq()	endifEndFunction JT_FindSpikeFreq()	Print "Doing automatic frequency detection."	String		ListOfWaves = TraceNameList("",";",1)	Variable	nWaves = ItemsInList(ListOfWaves)	if (nWaves==0)		Abort "No traces in graph."	endif	Variable	i	String		currWave,maxWave	Variable	maxAmplitude = -Inf	Variable	currAmplitude		// Find x axis range	GetAxis/Q	bottom	Variable	x1 = V_min	Variable	x2 = V_max		// Find wave with max deflection within range	i = 0	do		currWave = StringFromList(i,ListOfWaves)		WaveStats/Q/R=(x1,x2) $currWave		currAmplitude = V_max-V_min		if (maxAmplitude<currAmplitude)			maxAmplitude = currAmplitude			maxWave = currWave		endif		i += 1	while (i<nWaves)		// Find spikes	Variable	skip = 0.004//	Variable	SpikeThr = -30e-3	WaveStats/Q	$(maxWave)	Variable	SpikeThr = abs(V_max-V_min)*0.8+V_min	print "Using spike threshold:",SpikeThr," to operate on wave",maxWave,V_max-V_min,V_max,V_min	//	FindPeak/Q/R=(x1,x2)/M=(SpikeThr/1000) $maxWave	FindLevel/R=(x1,x2) /Q/EDGE=1 $maxWave,SpikeThr	if (V_Flag)		print "\t",maxWave,"Spike 1 not found"		Abort "Spike 1 not found"	endif//	Variable	AP1 = V_PeakLoc	Variable	AP1 = V_LevelX//	FindPeak/Q/R=(AP1+skip,x2)/M=(SpikeThr/1000) $maxWave	FindLevel/R=(AP1+skip,x2) /Q/EDGE=1 $maxWave,SpikeThr	if (V_Flag)		print "\t",maxWave,"Spike 2 not found"		Abort "Spike 2 not found"	endif//	Variable	AP2 = V_PeakLoc	Variable	AP2 = V_LevelX	Variable	Freq = 1/abs(AP2-AP1)		Cursor A,$maxWave,AP1	Cursor B,$maxWave,AP2		print "Frequency:",Freq,"Hz in trace "+maxWaveEnd////////////////////////////////////////////////////////////////////////////////////// Dump R_in as taken from MP_DatAnFunction R_in()	NVAR		ApproxPreSealTest = root:DatAn:ApproxPreSealTest			// Approximate presynaptic sealtest [Ohm]	NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]		Print ApproxPreSealTest/1e6	Print ApproxPostSealTest/1e6End////////////////////////////////////////////////////////////////////////////////////// Dump V_m as taken from MP_DatAnFunction V_m()	NVAR		ApproxPreVm = root:DatAn:ApproxPreVm					// Approximate presynaptic V_m or I_m	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	Print "If in voltage clamp:"	Print "\t",ApproxPreVm*1e9,"nA"	Print "\t",ApproxPostVm*1e9,"nA"	Print "If in current clamp:"	Print "\t",ApproxPreVm*1e3,"mV"	Print "\t",ApproxPostVm*1e3,"mV"End////////////////////////////////////////////////////////////////////////////////////// Extract data about EPSPFunction FitEPSP_30()	FitEPSP(30)	EndFunction FitEPSP_10()	FitEPSP(10)	EndFunction FitEPSP(SpikeAt)	Variable	SpikeAt				// Location of action potential in ms	Variable 	Shift = 0	Variable	Command = 0	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means voltage clamp."		Shift = 1	endif	if (Keys & 2^0)		Print "\tYou pressed the Command key. This means amplitude initial guess will be smaller."		Command = 1	endif	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before// SynapseAmp*((1-exp(-((p-i1)/SampleFreq)/(tau1*1e-3)))-(1-exp(-((p-i1)/SampleFreq)/(tau2*1e-3))))// SynapseAmp*( (1-exp(-x/tau1)) - (1-exp(-x/tau2)) )	String		TraceStr	Variable	winSize = 0.001	String	cursorInfo = csrInfo(A)	if (StrLen(cursorInfo)==0)		Beep		Print "Cursor A is not on a trace!"		Abort "Cursor A is not on a trace!"	endif	TraceStr = StringByKey("TNAME",cursorInfo)	print "Working on",TraceStr	WAVE	w = $TraceStr	Variable baseline = Mean(w,xcsr(A)-winSize,xcsr(A))	if (Shift)		if (baseline>0)			baseline = 0		endif	else		if (baseline<0)			baseline = 0		endif	endif	Make/D/N=4/O W_coef	// {tau1, tau2, amp, x0}	if (Shift)		W_coef[0] = {0.0005,0.003,-100e-12,SpikeAt/1e3}	else		W_coef[0] = {0.003,0.008,4e-3,SpikeAt/1e3}	endif	if (Command)		W_coef[2] /= 5	endif	Variable/G	V_FitMaxIters = 300	FuncFit/L=4000/Q/X=1 BiExp W_coef  w[pcsr(A),pcsr(B)] /D 	print "Tau 1:",W_coef[0]*1e3	print "Tau 2:",W_coef[1]*1e3	JT_RT_from_BiExp("fit_"+TraceStr,Shift)	if (Shift)		WaveStats/Q/R=(xcsr(A),xcsr(B)) w		Variable	minVal = Mean(w,V_minloc-winSize/5,V_minloc+winSize/5)		print "amp:",(minVal-baseline)*1e12,"at",V_minloc	else		WaveStats/Q/R=(xcsr(A),xcsr(B)) w		Variable	maxVal = Mean(w,V_maxloc-winSize/2,V_maxloc+winSize/2)		print "amp:",(maxVal-baseline)*1e3,"at",V_maxloc	endif	print "x0:",W_coef[3]*1e3-SpikeAt		FindLevel/Q/R=(xcsr(B),xcsr(A)-winSize*2) $("fit_"+TraceStr),baseline	if (V_flag)		Print "Level not found",baseline,"fit_"+TraceStr		Abort "Level not found"	endif	print "latency:",V_LevelX*1e3-SpikeAt	EndFunction JT_RT_from_BiExp(fitWaveName,NegPeak)	String		fitWaveName	Variable	NegPeak		WAVE		w = $fitWaveName	WaveStats/Q w														// Peak location	Variable	MaxLoc = V_maxloc	Variable	MaxVal = V_max	WaveStats/Q w														// Find baseline (min location)	Variable	MinLoc = V_minloc	Variable	MinVal = V_min		Variable	EPSPMagn = abs(MaxVal-MinVal)						// EPSP size		Variable	At20_x,At80_x		if (NegPeak)		FindLevel/Q w,(MinVal+EPSPMagn*0.8)						// Find 20%		At20_x = V_LevelX		FindLevel/Q w,(MinVal+EPSPMagn*0.2)						// Find 80%		At80_x = V_LevelX	else		FindLevel/Q w,(MinVal+EPSPMagn*0.2)						// Find 20%		At20_x = V_LevelX		FindLevel/Q w,(MinVal+EPSPMagn*0.8)						// Find 80%		At80_x = V_LevelX	endif		Variable	RT = (At80_x-At20_x)*1e3	//print "\tRise time is: ",RT," ms (20% to 80%, as extracted from fit)"		return RTendFunction BiExp(w,x) : FitFunc	Wave w	Variable x	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = (x<x0)? 0 : amp*( (1-exp(-(x-x0)/tau1)) - (1-exp(-(x-x0)/tau2)) )	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 4	//CurveFitDialog/ w[0] = tau1	//CurveFitDialog/ w[1] = tau2	//CurveFitDialog/ w[2] = amp	//CurveFitDialog/ w[3] = x0	return (x<w[3])? 0 : w[2]*( (1-exp(-(x-w[3])/w[0])) - (1-exp(-(x-w[3])/w[1])) )End////////////////////////////////////////////////////////////////////////////////////// Fit exponential and extract time constantFunction JT_fitExp()	String	TraceStr	String	cursorInfo = csrInfo(B)	if (StrLen(cursorInfo)==0)		Beep		Print "Cursor B is not on a trace!"		Abort "Cursor B is not on a trace!"	endif	cursorInfo = csrInfo(A)	if (StrLen(cursorInfo)==0)		Beep		Print "Cursor A is not on a trace!"		Abort "Cursor A is not on a trace!"	endif	TraceStr = StringByKey("TNAME",cursorInfo)	print "Working on",TraceStr	WAVE	w = $TraceStr	Variable/G	V_FitMaxIters = 300	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "--- You pressed the Shift key -- Fitting a double-exponential instead of an exponential."		CurveFit/N/Q dblexp_XOffset  w[pcsr(A),pcsr(B)] /D 		WAVE	W_coef		print "Offset:",W_coef[0]		print "Amplitude 1:",W_coef[1]		print "Tau 1:",W_coef[2]		print "Amplitude 2:",W_coef[3]		print "Tau 2:",W_coef[4]		print "Putting data on clipboard..."		PutScrapText  num2str(W_coef[0])+"\t"+num2str(W_coef[1])+"\t"+num2str(W_coef[2])+"\t"+num2str(W_coef[3])+"\t"+num2str(W_coef[4])	else		Print "--- Fitting an exponential."		CurveFit/N/Q exp_XOffset  w[pcsr(A),pcsr(B)] /D 		WAVE	W_coef		print "Offset:",W_coef[0]		print "Amplitude:",W_coef[1]		print "Tau:",W_coef[2]		print "Putting data on clipboard..."		PutScrapText  num2str(W_coef[0])+"\t"+num2str(W_coef[1])+"\t"+num2str(W_coef[2])	endif		DoUpdate	Variable yoffs = ReadYOffset(TraceStr)	Variable xoffs = ReadXOffset(TraceStr)	ModifyGraph offset($("fit_"+TraceStr))={xoffs,yoffs}	String		rgbStr =  StringByKey("rgb(x)",TraceInfo("",TraceStr,0),"=",";")	Variable	RR,GG,BB	sscanf		rgbStr,"(%f,%f,%f)", RR,GG,BB	if (RR+GG+BB==0)		BB = 65535	endif	ModifyGraph rgb($("fit_"+TraceStr))=(BB,GG,RR)	ModifyGraph lsize($("fit_"+TraceStr))=2End////////////////////////////////////////////////////////////////////////////////////// Duplicate the top graphFunction JT_DuplicateGraph()	if (Str2Num(StringByKey("IGORVERS",IgorInfo(0)))>=5.04)			if (StringMatch(StringFromList(0,WinList("*",";","WIN:")),"JT_Panel"))			DoWindow/B JT_Panel			Execute WinRecreation("", 0)			DoWindow/F JT_Panel		else			Execute WinRecreation("", 0)		endif			else			Beep;Print "This function requires Igor PRO v5.04 or higher."			endifEnd////////////////////////////////////////////////////////////////////////////////////// Take the trace name indicated by cursor A and collect it in the global string JT_tracesFunction JT_GatherTraceNames()	// Check for shift key being pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		if (exists("JT_traces"))			Print "\tYou pressed the Shift key -- Emptying the {JT_traces} string."//			KillStrings/Z	JT_traces			SVAR		JT_traces			JT_traces = ""		else			Print "\tYou pressed the Shift key -- Creating an empty {JT_traces} string."			String/G	JT_traces = ""		endif	else		if (exists("JT_traces")!=2)			print "Creating {JT_traces} -- This trace is the first entry..."			String/G	JT_traces		else			SVAR	JT_Traces		endif		String	cursorInfo = csrInfo(A)		if (StrLen(cursorInfo)==0)			Beep			Print "Cursor A is not on a trace!"		else			String	ExtractTraceStr = StringByKey("TNAME",cursorInfo)			Print "--- Adding \""+ExtractTraceStr+"\" to the {JT_traces} string... Use ListToGraph(JT_Traces) to produce graph."			JT_Traces += ExtractTraceStr+","		endif	endifEnd////////////////////////////////////////////////////////////////////////////////////// Take all traces in top graph and spread them apart along the y axis for added visibilityFunction JT_SpreadTracesInGraph()	Variable	DoSpread	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Spreading all traces in this graph:",NameTop	DoWindow/F $NameTop	// Check for shift key being pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key -- Setting Y offsets back to zero."		DoSpread = 0	else		DoSpread = 1	endif	DoSpreadTracesInGraph(NameTop,DoSpread)End	Function DoSpreadTracesInGraph(GraphNameString,DoSpread)	String		GraphNameString	Variable		DoSpread					// Boolean: If zero, then set offsets back to zero		Variable	Verbose = 0	Variable	xOffs//	String		ListOfWaves = WaveList("*",";","WIN:"+GraphNameString)	String		ListOfWaves = TraceNameList(GraphNameString,";",1)	Variable	nWaves = ItemsInList(ListOfWaves)	if (nWaves==0)		Abort "No traces in graph."	endif	Variable	i	String		currWave	Variable	maxAmplitude = -Inf	Variable	currAmplitude		if (Verbose)		Print "\t\t{JT_SpreadTracesInGraph} working on "+GraphNameString		Print "\t\t\t{JT_SpreadTracesInGraph} found ",nWaves," traces in graph"	endif		// Find x axis range	GetAxis/Q/W=$(GraphNameString) bottom	Variable	x1 = V_min	Variable	x2 = V_max		// Find Max	i = 0	do		currWave = StringFromList(i,ListOfWaves)		xOffs = ReadXOffset(currWave)		WaveStats/Q/R=(x1-xOffs,x2-xOffs) $currWave		currAmplitude = V_max-V_min		if (maxAmplitude<currAmplitude)			maxAmplitude = currAmplitude		endif		i += 1	while (i<nWaves)		maxAmplitude *= 1.1			// Add a few percent to get a nice gap between traces!	// Check for shift key being pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^0)		Print "\tYou pressed the Command key -- using smaller Y shift."		maxAmplitude /= 3	endif	Variable	doXshift = 0	Variable	Xshift = abs(x2-x1)*0.05	if (Keys & 2^1)		Print "You pressed the Option key -- spreading traces along the x axis too."		doXshift = 1	endif	if (Verbose)		Print "\t\t\t{JT_SpreadTracesInGraph} found maxAmplitude:",maxAmplitude		if (DoSpread==0)			Print "\t\t\t{JT_SpreadTracesInGraph} But will set offsets to zero!"		endif	endif		if (maxAmplitude==0)			// Stupid fix for the case when all waves are exactly zero		maxAmplitude = 1		SetAxis left,-maxAmplitude*(nWaves-1)-0.5,0.5		if (DoSpread==0)			SetAxis/A left		endif	endif	// Spread the waves	i = 0	do		currWave = StringFromList(i,ListOfWaves)		xOffs = ReadXOffset(currWave)		if (doXshift)			xOffs -= Xshift*(i-nWaves/2)		endif		if (DoSpread)			ModifyGraph/W=$(GraphNameString) offset($currWave)={xOffs,-maxAmplitude*i}		else			ModifyGraph/W=$(GraphNameString) offset($currWave)={0,0}		endif		i += 1	while (i<nWaves)End///////////////////////////////////////////////////////////////////////////////////////// Invert order of traces in top graphFunction JT_InvertTraceOrder()	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Inverting order of traces in this graph:",NameTop	DoWindow/F $NameTop	String		ListOfWaves = TraceNameList(NameTop,";",1)	Variable	nWaves = ItemsInList(ListOfWaves)	if (nWaves==0)		Abort "No traces in graph."	endif		String		currWave	String		nextWave	Variable	i	i = 0	do		currWave = StringFromList(i,ListOfWaves)		nextWave = StringFromList(i+1,ListOfWaves)		DelayUpdate		ReorderTraces/W=$(NameTop) $currWave,{$nextWave}		i += 1	while(i<nWaves-1)	DoUpdateEnd///////////////////////////////////////////////////////////////////////////////////////// Plot x number of traces from a cell with a certain base numberFunction JT_MakePTFCPanel()	DoWindow	JT_PlotTracesFromCellPanel	if (V_flag)				DoWindow/F	JT_PlotTracesFromCellPanel		else		Variable	linH = 22			Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution				Variable	xPos = 150		Variable	yPos = 60		Variable	Width = 260		Variable	Height = 32//+linH*9+4				Variable/G	JT_PTFC_StartAt = 10		Variable/G	JT_PTFC_nTraces = 25		Variable/G	JT_PTFC_Step = 1		String/G	JT_PTFC_cellName = "Cell_05_"		String/G	JT_PTFC_suffix = ""			DoWindow/K JT_PlotTracesFromCellPanel		NewPanel /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc)		DoWindow/C JT_PlotTracesFromCellPanel		SetDrawLayer UserBack		SetDrawEnv fsize= 14,fstyle= 1+4,textxjust= 1,textyjust= 2		DrawText Width/2,6,"Plot traces from cell"				Variable	ySkip = 32		Button PlotNowButton,pos={4+Width*0/2,ySkip},size={Width-4,18},title="Plot traces now",Proc=JT_PlotTracesFromCellProc		ySkip += linH		SetVariable JT_PTFC_baseNameSetVar,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Basename:"		SetVariable JT_PTFC_baseNameSetVar,limits={-1,-1,-1},value=JT_PTFC_cellName		SetVariable JT_PTFC_suffixSetVar,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="Suffix:"		SetVariable JT_PTFC_suffixSetVar,limits={-1,-1,-1},value=JT_PTFC_suffix		ySkip += linH		SetVariable JT_PTFC_StartAtSetVar,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Start at:"		SetVariable JT_PTFC_StartAtSetVar,limits={1,Inf,1},value=JT_PTFC_StartAt		SetVariable JT_PTFC_nTracesSetVar,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="# of traces:"		SetVariable JT_PTFC_nTracesSetVar,limits={0,Inf,1},value=JT_PTFC_nTraces		ySkip += linH		SetVariable JT_PTFC_StepSetVar,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Step:"		SetVariable JT_PTFC_StepSetVar,limits={1,Inf,1},value=JT_PTFC_Step		Button KillPanelButton,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="Kill panel",Proc=JT_KillPTFCPanelProc,fColor=(65535,65535/2,65535/2)		ySkip += linH			Height = ySkip+4		MoveWindow/W=JT_PlotTracesFromCellPanel xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc		// Adjust panel size based on number of controls added to it...	endifEndFunction JT_PlotTracesFromCellProc(ctrlName) : ButtonControl	String ctrlName	Print "--- Plot traces from cell ---"	NVAR		JT_PTFC_StartAt	NVAR		JT_PTFC_nTraces	NVAR		JT_PTFC_Step	SVAR		JT_PTFC_cellName	SVAR		JT_PTFC_suffix		Print		"\tCell: "+JT_PTFC_cellName+"xxxx"+JT_PTFC_suffix,"\r\tStarting at:",JT_PTFC_StartAt,"--- number of traces:",JT_PTFC_nTraces,"--- step size:",JT_PTFC_Step		Variable	nDig = 4	String		graphName = JT_PTFC_cellName+"xxxx"+JT_PTFC_suffix+"_graph"	String		currWave		DoWindow/K	$graphName	Display/W=(150,240,460,420)	as graphName	DoWindow/C	$graphName	Variable	i	i = JT_PTFC_StartAt	do		currWave = JT_PTFC_cellName+JT_num2digstr(nDig,i)+JT_PTFC_suffix		AppendToGraph/W=$graphName $currWave		i += JT_PTFC_Step	while(i<(JT_PTFC_StartAt+JT_PTFC_nTraces))	Print "--- Done ---"EndFunction JT_KillPTFCPanelProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/K JT_PlotTracesFromCellPanelEnd///////////////////////////////////////////////////////////////////////////////////////// Remove extracellular stim artifacts of traces in top graphFunction MakeStimArtifactPanel()	DoWindow	StimArtifactPanel	if (V_flag)				DoWindow/F	StimArtifactPanel		else		Variable	linH = 22			Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution				Variable	xPos = 150		Variable	yPos = 60		Variable	Width = 260		Variable	Height = 32//+linH*9+4				Variable/G	RSA_StartAt = 0.8		Variable/G	RSA_Width = 2		Variable/G	RSA_Freq = 50		Variable/G	RSA_nArtifacts = 5			DoWindow/K StimArtifactPanel		NewPanel /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc)		DoWindow/C StimArtifactPanel		SetDrawLayer UserBack		SetDrawEnv fsize= 14,fstyle= 1+4,textxjust= 1,textyjust= 2		DrawText Width/2,6,"Remove Stim Artifact"				Variable	ySkip = 32		Button RemoveItButton,pos={4+Width*0/2,ySkip},size={Width-4,18},title="Remove artifacts now",Proc=RemoveStimArtifact		ySkip += linH		Button UseCursorDataButton,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Use cursors",Proc=UseCursorData		Button KillPanelButton,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="Kill panel",Proc=KillStimArtifactPanel,fColor=(65535,65535/2,65535/2)		ySkip += linH		SetVariable RSA_StartAtSetVar,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Start at [s]:"		SetVariable RSA_StartAtSetVar,limits={0,Inf,0.1},value=RSA_StartAt		SetVariable RSA_WidthSetVar,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="width [ms]:"		SetVariable RSA_WidthSetVar,limits={0,Inf,1},value=RSA_Width		ySkip += linH		SetVariable RSA_FreqSetVar,pos={4+Width*0/2,ySkip},size={Width/2-4,18},title="Frequency [Hz]:"		SetVariable RSA_FreqSetVar,limits={1,Inf,5},value=RSA_Freq		SetVariable RSA_nArtifactsSetVar,pos={4+Width*1/2,ySkip},size={Width/2-4,18},title="# of artifacts:"		SetVariable RSA_nArtifactsSetVar,limits={1,Inf,1},value=RSA_nArtifacts		ySkip += linH		CheckBox FillWithWhatCheck,pos={4+Width*0/2,ySkip},size={Width-4,18},title="Fill with NaN (otherwise intrapolate from edges)",value=0		ySkip += linH			Height = ySkip+4		MoveWindow/W=StimArtifactPanel xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc		// Adjust panel size based on number of controls added to it...	endifEndFunction KillStimArtifactPanel(ctrlName) : ButtonControl	String ctrlName	DoWindow/K StimArtifactPanelEndFunction UseCursorData(ctrlName) : ButtonControl	String ctrlName//	DoWindow/K StimArtifactPanel	NVAR	RSA_StartAt	NVAR	RSA_Width		Variable	x1 = xcsr(A)	Variable	x2 = xcsr(B)	Variable	temp		if (x1>x2)		temp = x1		x1 = x2		x2 = temp	endif		RSA_StartAt = Round(x1*1000)/1000	RSA_Width = Round((x2-x1)*10000)/10EndFunction RemoveStimArtifact(ctrlName) : ButtonControl	String ctrlName	NVAR	RSA_StartAt	NVAR	RSA_Width	NVAR	RSA_Freq	NVAR	RSA_nArtifacts	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Removing stimulus artifacts in this graph:",NameTop	DoWindow/F $NameTop		Controlinfo/W=StimArtifactPanel FillWithWhatCheck	Variable	FillWithNaN = V_Value	String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Variable	i,j	i = 0	do		currWave = StringFromList(i,TraceList)		print "Working on ",currWave		j = 0		do			DoRemoveStimArtifact(RSA_StartAt+j/RSA_Freq,RSA_Width,currWave,FillWithNaN)			j += 1		while(j<RSA_nArtifacts)		i += 1	while(i<nWaves)EndFunction DoRemoveStimArtifact(pos,wid,wName,FillWithNaN)	Variable	pos	Variable	wid	String		wName	Variable	FillWithNaN		WAVE	w = $wName	Variable	iPol_y1,iPol_y2	Variable	k,m	if (FillWithNaN)		w[x2pnt(w,pos),x2pnt(w,pos+wid/1000)] = NaN//		print pos,pos+wid/1000,x2pnt(w,pos),x2pnt(w,pos+wid/1000)	else		iPol_y1 = w[x2pnt(w,pos)-1]		iPol_y2 = w[x2pnt(w,pos+wid/1000)+1]		k = (iPol_y2-iPol_y1)/(x2pnt(w,pos+wid/1000)+1-(x2pnt(w,pos)-1))		m = iPol_y1 - k*(x2pnt(w,pos)-1)		 // y = k*x + m		w[x2pnt(w,pos),x2pnt(w,pos+wid/1000)] = k*p+m	endifEnd///////////////////////////////////////////////////////////////////////////////////////// Take a list of waves and make a graph of themFunction ListToGraph_JT_Traces()	SVAR	JT_Traces	JT_ListToGraph(JT_Traces)EndFunction JT_ListToGraph(TraceList)	String		TraceList	Variable	nWaves = ItemsInList(TraceList,",")	String		separatorStr = ","	Variable	nWaves2 =  ItemsInList(TraceList,";")	if (nWaves2>nWaves)		separatorStr = ";"		nWaves = nWaves2	endif	print "Found "+num2str(nWaves)+" waves with the separator string \""+separatorStr+"\"."	String		currWave	Variable	Appending = 0		Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the Shift key -- Appending waves instead of creating a new graph."		Appending = 1	else		Display		endif	Variable	i = 0	do		currWave = StringFromList(i,TraceList,separatorStr)		if (StrLen(currWave)>0)			if (Exists(currWave)==1)				AppendToGraph $currWave				if (Appending)					ModifyGraph RGB($currWave)=(0,0,65535)				endif			else				print "{JT_ListToGraph} cannot find \""+currWave+"\""			endif		endif		i += 1	while(i<nWaves)EndFunction JT_WaveNoteToGraph(theWave)	WAVE	theWave		String	WavesInNote = Note(theWave)	JT_ListToGraph(WavesInNote)	End///////////////////////////////////////////////////////////////////////////////////////// Simple fix to make sure I remember which commands do whatFunction JT_PrintDoTTest()	print "-------------------------"	print "T test for differences of the means. Data is unpaired and in two waves."	print "The below line of text is now in the clipboard:"	print "DoTTest(w1,w2)"	PutScrapText "DoTTest(w1,w2)"EndFunction JT_Printnw()	print "-------------------------"	print "Name top window, including graphs, panels, and tables."	print "Note that you need to pass name as a string."	print "Illegal characters in name will be eliminated, but will be kept in title."	print "The below line of text is now in the clipboard:"	print "nw(\"new_name\")"	PutScrapText "nw(\"new_name\")"EndFunction JT_Printqp()	print "-------------------------"	print "Quick scatter Plot, including r value and Pearson's test."	print "Graph name is based on wave names."	print "X and Y axes are labelled with corresponding wave names."	print "Note that you need to pass wave names as a strings."	print "The below line of text is now in the clipboard:"	print "qp(\"yAxisWave\",\"xAxisWave\")"	PutScrapText "qp(\"yAxisWave\",\"xAxisWave\")"EndFunction JT_PrintJT_QuickPaired()	print "-------------------------"	print "Quick paired T test on waves named w1 and w2."	print "Note that these names are not strings."	print "The below line of text is now in the clipboard:"	print "\t\tJT_QuickPaired(w1,w2)"	print "[To include the means ± SEMs, use JT_QuickPairedWithMeans(w1,w2) instead.]"	PutScrapText "JT_QuickPaired(w1,w2)"EndFunction JT_PrintJT_BarGraphFDWN()	print "-------------------------"	print "Make a bar graph from two waves and name that graph."	print "Note that these names are all strings."	print "The below line of text is now in the clipboard:"	print "JT_BarGraphFromDataWithName(\"cond1\",\"cond2\",\"theName\")"	print "For three bars, use:"	print "JT_3BarGraphFromDataWithName(\"cond1\",\"cond2\",\"cond3\",\"theName\")"	PutScrapText "JT_BarGraphFromDataWithName(\"cond1\",\"cond2\",\"theName\")"EndFunction JT_PrintJT_MakeHist()	print "-------------------------"	print "Make a nice histogram graph from one wave and name that graph and its x axis label."	print "Note that these names are all strings, except numBins, which is a numeric variable."	print "Start and end of histogram is determined by data limits."	print "The below line of text is now in the clipboard:"	print "JT_MakeHist(\"wName\",numBins,\"xLabel\",\"Title\")"	PutScrapText "JT_MakeHist(\"wName\",numBins,\"xLabel\",\"Title\")"EndFunction JT_PrintJT_ScatterWithMeans()	print "-------------------------"	print "Takes yWave and xWave and produces a scatter plot with CV-analysis style means"	print "on the x and the y axes."	print "The below line of text is now in the clipboard:"	// Figure out options and keys pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the Shift key."		print "Duplicate/O ChangeJesperWave,tempWave;tempWave/=100;JT_ScatterWithMeans(PrePostInvCVSq2binWave,tempWave)"		PutScrapText "Duplicate/O ChangeJesperWave,tempWave;tempWave/=100;JT_ScatterWithMeans(PrePostInvCVSq2binWave,tempWave)"	else		print "JT_ScatterWithMeans(yWave,xWave)"		PutScrapText "JT_ScatterWithMeans(yWave,xWave)"	endifEnd///////////////////////////////////////////////////////////////////////////////////////// Do stats on two conditionsFunction DoTTest(wName1,wName2)	WAVE		wName1	WAVE		wName2	Variable	pVal = CorrectedStatTTest(wName1,wName2)		Print "Wave 1:",NameOfWave(wName1)	WaveStats/Q wName1	Print "Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),", n = ",V_npnts	Print "Wave 2:",NameOfWave(wName2)	WaveStats/Q wName2	Print "Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),", n = ",V_npnts	Print "p (t-test for difference of the means) = ",pVal	StatsFTest/Q wName1,wName2	WAVE		W_StatsFTest	if (W_StatsFTest[11]<0.05)		print "\tp (F test) = ",W_StatsFTest[11],"(unequal variances)"	else		print "\tp (F test) = ",W_StatsFTest[11],"(equal variances)"	endif		JT_doWilcoxon(wName1,wName2)	return pVal	End///////////////////////////////////////////////////////////////////////////////////////// Non-parametric Wilcoxon testFunction JT_doWilcoxon(w1,w2)	WAVE		w1	WAVE		w2	Variable	n1,n2	Variable	pVal		Duplicate/O	w1,JT_wTemp1	Duplicate/O	w2,JT_wTemp2	// NaNs affect non-parametric p values, so remove all NaNs before testing!	JT_RemoveNaNs(JT_wTemp1)	JT_RemoveNaNs(JT_wTemp2)	WaveStats/Z/Q JT_wTemp1	n1 = V_npnts	WaveStats/Z/Q JT_wTemp2	n2 = V_npnts		String	outStr = ""		if ( (n1>3) %& (n2>3) )		if (n1+n2>40)			if (mean(JT_wTemp1)<mean(JT_wTemp2))						// Account for Igor bug				StatsWilcoxonRankTest/Q/APRX=2/TAIL=4 JT_wTemp1,JT_wTemp2			else				StatsWilcoxonRankTest/Q/APRX=2/TAIL=4 JT_wTemp2,JT_wTemp1			endif			outStr = "p (Wilcoxon-Mann-Whitney two-sample rank test) [with Zar's normal approximation due to large total n] = "		else			StatsWilcoxonRankTest/Q/TAIL=4 JT_wTemp1,JT_wTemp2			outStr = "p (Wilcoxon-Mann-Whitney two-sample rank test) = "		endif		WAVE		W_WilcoxonTest		pVal = W_WilcoxonTest[5]		print OutStr,pVal			else			pVal = -1	endif		KillWaves/Z JT_wTemp1,JT_wTemp2		Return pValEnd///////////////////////////////////////////////////////////////////////////////////////// Paired t-testFunction DoPairedTTest(wName1,wName2)	WAVE	wName1	WAVE	wName2		Variable	p		StatsTTest/Q/PAIR/Z wName1,wName2 // Add /T=1 to show table	WAVE	W_StatsTTest	p = W_StatsTTest[6]	WaveStats/Q wName1	Print "Wave 1:",NameOfWave(wName1)," -- Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	WaveStats/Q wName2	Print "Wave 2:",NameOfWave(wName2)," -- Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	Print "p (paired t-test) = ",p	StatsWilcoxonRankTest/WSRT/Q/TAIL=4 wName1,wName2	WAVE		W_WilcoxonTest	Print "p (Wilcoxon Signed Rank test) = ",W_WilcoxonTest[5]	Print "---"		Return pEnd///////////////////////////////////////////////////////////////////////////////////////// Do stats on one condition Function JT_oneSampleTTest(wName1,theValue)	WAVE		wName1	Variable	theValue	Print "Wave:",NameOfWave(wName1)	WaveStats/Q wName1	Print "Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),", n = ",V_npnts	StatsTTest/MEAN=(theValue)/Q wName1	WAVE		W_StatsTTest	Variable	pVal = W_StatsTTest[7]	Print "p (one-sample t-test versus the value "+num2str(theValue)+") = ",pVal	Duplicate/O	wName1,JT_dummyWave	JT_dummyWave = theValue	StatsWilcoxonRankTest/Q/TAIL=4 wName1,JT_dummyWave	WAVE		W_WilcoxonTest	Print "\tp (Wilcoxon Signed Rank Test versus the value "+num2str(theValue)+") = ",W_WilcoxonTest[5]	if (JT_waveHasNaNs(wName1))		Beep		print "\tWARNING!!! "+NameOfWave(wName1)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	Print "---"		return pVal	End///////////////////////////////////////////////////////////////////////////////////////// Do meanFunction DoMean(wName1)	WAVE	wName1	Print "Wave:",NameOfWave(wName1)	WaveStats/Q wName1	Print "Mean =",V_avg,"±",V_sdev/sqrt(V_npnts),", n = ",V_npnts,"min=",V_min,"max=",V_max	End//////////////////////////////////////////////////////////////////////////////////// This function replaces all data in all waves in the top graph between pcsr(A) and pcsr(B)//// with NaNs. Warning! -- use with some caution...Function RemoveData()	Print "--- Remove data ---"	String		Name = WinName(0,1)		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Variable	p1 = pcsr(A)	Variable	p2 = pcsr(B)		Variable	i = 0	do		currWave = StringFromList(i,TraceList)		print "Working on ",currWave		WAVE	w = $currWave		w[p1,p2] = NaN		i += 1	while(i<nWaves)End//////////////////////////////////////////////////////////////////////////////////// Set DefaultFont to HelveticaFunction FontIsHelvetica()	// Figure out options and keys pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^0)		Print "You pressed the Command key -- default font is now Arial."		DefaultFont/U "Arial"	else		Print "Default font is now Helvetica."		DefaultFont/U "Helvetica"	endifEnd//////////////////////////////////////////////////////////////////////////////////// Produce calibrator in the ProgFront layerFunction ProduceCalibrator()	// Make sure top window is a graph		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print "Appending calibrator to this graph:",NameTop	DoWindow/F $NameTop	// Empty the drawing layer//	SetDrawLayer/K ProgFront//	SetDrawLayer ProgFront	Variable	div = 5	Variable	xSize = 5	Variable	ySize = 5		// Figure out options and keys pressed	Variable Keys = GetKeyState(0)	if (Keys & 2^1)		Print "You pressed the Option key -- reducing the xAxis size value."		xSize = 2	else		if (Keys & 2^0)			Print "You pressed the Command key -- increasing the xAxis size value."			xSize = 10		endif	endif	if (Keys & 2^2)		Print "You pressed the Shift key -- reducing the yAxis size value."		ySize = 2	else		if (Keys & 2^3)			Print "You pressed the Caps Lock key -- increasing the yAxis size value."			ySize = 10		endif	endif		// Calculate X axis	GetAxis/Q bottom	Variable	xMin = V_min	Variable	xMax = V_max	Variable	xRange = xMax-xMin	Variable	xOffs = xMin+0.1*xRange	Variable	absxSize = 10^floor(log(xRange/div))*xSize		Print "xSize =",absxSize		// Calculate Y axis	GetAxis/Q left	Variable	yMin = V_min	Variable	yMax = V_max	Variable	yRange = yMax-yMin	Variable	yOffs = yMin+0.1*yRange	Variable	absySize = 10^floor(log(yRange/div))*ySize		Print "ySize =",absySize		Variable	theLineThick = 1		// Draw X axis	SetDrawEnv xcoord=bottom, ycoord=left,linethick= theLineThick	DrawLine xOffs,yOffs,xOffs+absxSize,yOffs	// Draw Y axis	SetDrawEnv xcoord=bottom, ycoord=left,linethick= theLineThick	DrawLine xOffs,yOffs,xOffs,yOffs+absySize		// Add Y axis text	SetDrawEnv xcoord= bottom,ycoord= left,textyjust= theLineThick//,fstyle= 1	DrawText xOffs+0.1*absxSize,yOffs+absySize,num2str(ySize)//+" mV"	// Add X axis text	SetDrawEnv xcoord= bottom,ycoord= left,textyjust= theLineThick//,fstyle= 1	DrawText xOffs+0.1*absxSize,yOffs+absySize/2,num2str(xSize)//+" ms"End//////////////////////////////////////////////////////////////////////////////////// Copy cursor positions FROM next-to-top window TO top windowFunction CopyCursorPositions()	String		NameTop = WinName(0,1)	String		NameNext = WinName(1,1)		Print "Getting cursor positions from \""+NameNext+"\" and copying them to \""+NameTop+"\"."		Variable	Apos = xcsr(A,NameNext)	Variable	Bpos = xcsr(B,NameNext)		Print "Positions are ",Apos,"and",Bpos,"."		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Variable	i		i = 0		// Make sure not to put the cursors on the risetimes wave, if there is one...	do		currWave = StringFromList(i,TraceList)		i += 1	while(StringMatch(currWave,"JT_RiseTimePoints_y"))		Cursor A,$currWave,Apos	Cursor B,$currWave,Bpos	End	//////////////////////////////////////////////////////////////////////////////////// Copy axes ranges FROM next-to-top window TO top windowFunction CopyAxesRanges()	String		NameTop = WinName(0,1)	String		NameNext = WinName(1,1)		Print "Getting axes ranges from \""+NameNext+"\" and copying them to \""+NameTop+"\"."		Variable	leftTop	Variable	leftBottom	Variable	leftExists	Variable	rightTop	Variable	rightBottom	Variable	rightExists	Variable	bottomLeft	Variable	bottomRight	Variable	bottomExists	// Get Left	GetAxis/W=$(NameNext)/Q left	leftBottom = V_min	leftTop = V_max	leftExists = (!(V_flag))	// Get Right	GetAxis/W=$(NameNext)/Q right	rightBottom = V_min	rightTop = V_max	rightExists = (!(V_flag))	// Get Bottom	GetAxis/W=$(NameNext)/Q bottom	bottomLeft = V_min	bottomRight = V_max	bottomExists = (!(V_flag))		// Set Left	if (leftExists)		SetAxis/W=$(NameTop) left,leftBottom,leftTop		Print "Set left axis."	endif	// Set Right	if (rightExists)		SetAxis/W=$(NameTop) right,rightBottom,rightTop		Print "Set right axis."	endif	// Set Bottom	if (bottomExists)		SetAxis/W=$(NameTop) bottom,bottomLeft,bottomRight		Print "Set bottom axis."	endifEnd//////////////////////////////////////////////////////////////////////////////////// Take list of graph names, and scale all y axes from the same MIN value to the same//// MAX value.Function JT_MaxMinYAxis(GrList)	String		GrList		Variable	i	Variable	n = ItemsInList(GrList)	if (n<2)		Abort	endif	String		currGraph	Variable	minmin = Inf	Variable	maxmax = -Inf		i = 0	do		currGraph = StringFromList(i,GrList)		GetAxis/Q left		if (V_max>maxmax)			maxmax = V_max		endif		if (V_min<minmin)			minmin = V_min		endif		i += 1	while(i<n)		i = 0	do		currGraph = StringFromList(i,GrList)		SetAxis/W=$currGraph left,minmin,maxmax		i += 1	while(i<n)	End//////////////////////////////////////////////////////////////////////////////////// Get screen size in pixelsFunction JT_GetScreenSize()	String		ScreenInfo = StringByKey("SCREEN1",IgorInfo(0))	Variable		ResolutionStart = StrSearch(ScreenInfo,"=",10)	String		ResolutionList = ScreenInfo[ResolutionStart+1,StrLen(ScreenInfo)-1]	Variable/G	JT_ScreenWidth = Str2Num(StringFromList(2,ResolutionList,","))	Variable/G	JT_ScreenHeight = Str2Num(StringFromList(3,ResolutionList,","))		if (JT_thisIsWindows())		Variable	ScSc = PanelResolution("")/ScreenResolution		GetWindow kwFrameInner wsize		JT_ScreenWidth = abs(V_right-V_left)/ScSc		JT_ScreenHeight = abs(V_bottom-V_top)/ScSc	endif		Return		JT_ScreenWidthEnd//////////////////////////////////////////////////////////////////////////////////// Copy the window size from source to target windowFunction JT_CopyWindowSize(sourceWin,targetWin)	String		sourceWin,targetWin		if ( (StrLen(sourceWin)==0) %| (StrLen(targetWin)==0) )		Return -1	endif	doWindow	$sourceWin	if (V_flag==0)		Return -1	endif	doWindow	$targetWin	if (V_flag==0)		Return -1	endif		JT_CopyWindowWidth(sourceWin,targetWin)	JT_CopyWindowHeight(sourceWin,targetWin)		Return		0End//////////////////////////////////////////////////////////////////////////////////// Copy the window width from source to target windowFunction JT_CopyWindowWidth(sourceWin,targetWin)	String		sourceWin,targetWin		if ( (StrLen(sourceWin)==0) %| (StrLen(targetWin)==0) )		Return -1	endif	doWindow	$sourceWin	if (V_flag==0)		Return -1	endif	doWindow	$targetWin	if (V_flag==0)		Return -1	endif		String	sourceWinPos = JT_GetWinPos(sourceWin)	String	targetWinPos = JT_GetWinPos(targetWin)		String	revisedWinPos = RemoveListItem(2,targetWinPos)	revisedWinPos = AddListItem(StringFromList(2,sourceWinPos),revisedWinPos,";",2)		JT_PutWinPos(targetWin,revisedWinPos)		Return		0End//////////////////////////////////////////////////////////////////////////////////// Copy the window height from source to target windowFunction JT_CopyWindowHeight(sourceWin,targetWin)	String		sourceWin,targetWin		if ( (StrLen(sourceWin)==0) %| (StrLen(targetWin)==0) )		Return -1	endif	doWindow	$sourceWin	if (V_flag==0)		Return -1	endif	doWindow	$targetWin	if (V_flag==0)		Return -1	endif		String	sourceWinPos = JT_GetWinPos(sourceWin)	String	targetWinPos = JT_GetWinPos(targetWin)		String	revisedWinPos = RemoveListItem(3,targetWinPos)	revisedWinPos = AddListItem(StringFromList(3,sourceWinPos),revisedWinPos,";",3)		JT_PutWinPos(targetWin,revisedWinPos)		Return		0End//////////////////////////////////////////////////////////////////////////////////// Put window at position and size defined by the winPos string, which//// contains "x;y;width;height;"Function JT_PutWinPos(targetWin,winPos)	String		targetWin	String		winPos		if ( (StrLen(targetWin)==0) %| (StrLen(winPos)==0) )		Return -1	endif	doWindow	$targetWin	if (V_flag==0)		Return -1	endif	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1 = str2num(stringFromList(0,winPos))	Variable	y1 = str2num(stringFromList(1,winPos))	Variable	width = str2num(stringFromList(2,winPos))	Variable	height = str2num(stringFromList(3,winPos))	 	MoveWindow/W=$(targetWin) x1*ScSc,y1*ScSc,(x1+width)*ScSc,(y1+height)*ScSc	Return		0End	//////////////////////////////////////////////////////////////////////////////////// Get window positionFunction/S JT_GetWinPos(currName)	String		currName		Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1,x2	Variable	y1,y2	Variable	width,height	Variable	xPos = 64	Variable	yPos = 64	Variable	skip = 32*ScSc		GetWindow $currName, wsize	x1 = V_left/ScSc	x2 = V_right/ScSc	y1 = V_top/ScSc	y2 = V_bottom/ScSc	width = x2-x1	height = y2-y1// 	MoveWindow/W=$(currName) xPos*ScSc+skip*i,  yPos*ScSc+skip*i  ,(xPos+width)*ScSc+skip*i  ,(yPos+height)*ScSc+skip*i	String		coordList = ""	coordList += num2str(x1)+";"	coordList += num2str(y1)+";"	coordList += num2str(width)+";"	coordList += num2str(height)+";"	Return		coordListEnd		//////////////////////////////////////////////////////////////////////////////////// Tidy up graph windowsFunction JT_ArrangeGraphs(ListOfGraphNames)			// Stack graphs	String		ListOfGraphNames						// Semi-colon separated list	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1,x2	Variable	y1,y2	String		currName	Variable	width,height	Variable	xPos = 64	Variable	yPos = 64	Variable	skip = 32*ScSc		Variable	i	Variable	n = ItemsInList(ListOfGraphNames)//	Print "Arranging "+num2str(n)+" graphs."	i = 0	do		currName = StringFromList(i,ListOfGraphNames)		if (!(StringMatch(currName,"")))			if (i==0)				GetWindow $currName, wsize				x1 = V_left/ScSc				x2 = V_right/ScSc				y1 = V_top/ScSc				y2 = V_bottom/ScSc				width = x2-x1				height = y2-y1			endif			DoWindow $(currName)			// Only try to move windows that exist			if (V_flag>0)			 	MoveWindow/W=$(currName) xPos*ScSc+skip*i,  yPos*ScSc+skip*i  ,(xPos+width)*ScSc+skip*i  ,(yPos+height)*ScSc+skip*i			 endif		 endif		i += 1	while(i<n)EndFunction JT_ScreenSize(yAxis)	Variable	yAxis	JT_GetScreenSize()	NVAR		JT_ScreenWidth	NVAR		JT_SCreenHeight//	String		ScreenSizeStr = IgorInfo(0)//	ScreenSizeStr = ScreenSizeStr[StrSearch(ScreenSizeStr,"RECT=",0),inf]		Variable	xSize = JT_ScreenWidth	Variable	ySize = JT_SCreenHeight		if (yAxis)		Return ySize	else		Return xSize	endifEndFunction JT_ArrangeGraphs2(ListOfGraphNames,Rows,Columns)		// Put graphs in nice rows and columns	String		ListOfGraphNames						// Semi-colon separated list	Variable	Rows	Variable	Columns		Variable	xSize = JT_ScreenSize(0)	Variable	ySize = JT_ScreenSize(1)-34	Variable	xSkip = 8	Variable	ySkip = 36	Variable	xPos = 8	Variable	yPos = 64+14	Variable	width = (xSize-xPos)/Columns-xSkip	Variable	height = (ySize-yPos)/Rows-ySkip	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1	Variable	y1	String		currName		Variable	i	Variable	r = 0	Variable	c = 0	Variable	n = ItemsInList(ListOfGraphNames)//	Print "Arranging "+num2str(n)+" graphs."	i = 0	do		currName = StringFromList(i,ListOfGraphNames)		if (!(StringMatch(currName,"")))//			print "\tMoving: "+currName			x1 = xPos+c*(width+xSkip)			y1 = yPos+r*(height+ySkip)			DoWindow $(currName)			// Only try to move windows that exist			if (V_flag>0)			 	MoveWindow/W=$(currName) x1*ScSc, y1*ScSc ,(x1+width)*ScSc,(y1+height)*ScSc			endif		 endif	 	r += 1	 	if (r>Rows-1)	 		r = 0	 		c += 1	 		if (c>Columns-1)	 			c = 0	 		endif	 	endif		i += 1	while(i<n)EndFunction JT_ArrangeGraphs3(ListOfGraphNames)		// Graphs to front	String		ListOfGraphNames						// Semi-colon separated list	String		currName		Variable	i	Variable	n = ItemsInList(ListOfGraphNames)//	Print "Moving "+num2str(n)+" graphs to front."	i = 0	do		currName = StringFromList(i,ListOfGraphNames)		if (!(StringMatch(currName,"")))			DoWindow/F $(currName)		endif		i += 1	while(i<n)EndFunction JT_ArrangeGraphs4(ListOfGraphNames,dx,dy)	// Move graphs	String		ListOfGraphNames						// Semi-colon separated list	Variable	dx,dy	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1,x2	Variable	y1,y2	String		currName	Variable	width,height	Variable	xPos = 64	Variable	yPos = 64	Variable	skip = 32*ScSc		Variable	i	Variable	n = ItemsInList(ListOfGraphNames)//	Print "Moving "+num2str(n)+" graphs by ",dx,dy	i = 0	do		currName = StringFromList(i,ListOfGraphNames)		if (!(StringMatch(currName,"")))			GetWindow $currName, wsize			x1 = V_left/ScSc			x2 = V_right/ScSc			y1 = V_top/ScSc			y2 = V_bottom/ScSc			width = x2-x1			height = y2-y1			xPos = x1+dx			yPos = y1+dy//			print "\tMoving: "+currName			DoWindow $(currName)			// Only try to move windows that exist			if (V_flag>0)			 	MoveWindow/W=$(currName) xPos*ScSc+skip,  yPos*ScSc+skip  ,(xPos+width)*ScSc+skip  ,(yPos+height)*ScSc+skip			 endif		 endif		i += 1	while(i<n)EndFunction JT_ArrangeGraphs5(ListOfGraphNames)		// Kill graphs	String		ListOfGraphNames						// Semi-colon separated list	String		currName		Variable	i	Variable	n = ItemsInList(ListOfGraphNames)	if (n!=0)//		Print "Killing "+num2str(n)+"."		i = 0		do			currName = StringFromList(i,ListOfGraphNames)			if (!(StringMatch(currName,"")))				DoWindow/K $(currName)			endif			i += 1		while(i<n)	endifEndFunction JT_ArrangeGraphs6(ListOfGraphNames)		// Graphs to back	String		ListOfGraphNames						// Semi-colon separated list	String		currName		Variable	i	Variable	n = ItemsInList(ListOfGraphNames)//	Print "Moving "+num2str(n)+" graphs to back."	i = 0	do		currName = StringFromList(i,ListOfGraphNames)		if (!(StringMatch(currName,"")))			DoWindow/B $(currName)		endif		i += 1	while(i<n)End//////////////////////////////////////////////////////////////////////////////////// Measure EPSP amplitude in traces in top graphFunction JT_MeasureEPSPs(x1,x2,x3,x4)	Variable	x1,x2,x3,x4	String		TraceList = TraceNameList("",";",1)	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Make/O/N=(0)	JT_EPSPWave		Variable	y1,y2		Variable	i		i = 0	do		currWave = StringFromList(i,TraceList)		WAVE	w = $currWave		y1 = Mean(w,x1,x2)		y2 = Mean(w,x3,x4)		JT_EPSPWave[numpnts(JT_EPSPWave)] = {y2-y1}		i += 1	while(i<nWaves)	Print "Produced ",numpnts(JT_EPSPWave)," measurements and put them in the wave {JT_EPSPWave}."End//////////////////////////////////////////////////////////////////////////////////// General make query panel procedure — for inputting variables and names etcFunction JT_MakeQueryPanel(pTitle,HeaderList,fCallStr)	String		pTitle	String		HeaderList	String		fCallStr	String/G	ExecuteUponClosureStr = fCallStr		String		pName = JT_RemoveSpaces(pTitle)		Variable	n = ItemsInList(HeaderList)	Make/T/O/N=(n) JT_QueryWave		Variable	panWidth = 200	Variable	bHeight = 20	Variable	panHeight= 32+bHeight*3+4	Variable	xPos = 50	Variable	yPos = 50	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		DoWindow /K $pName	NewPanel /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScSc) as pTitle	DoWindow /C $pName	Variable	yShift = 0 // 32	Variable	mVar = 0		String		CurrTitle = ""	String		CurrName = ""	Variable	i		i = 0		do		CurrTitle = StringFromList(i,HeaderList)		CurrName = JT_RemoveSpaces(CurrTitle)		String/G	$("Var_"+CurrName)	 	//Add SetVariable		SetVariable $("Query_"+JT_Num2DigStr(4,i)), pos={4,4+yShift+mVar*bHeight}, size={panWidth-8,17}, proc=JT_EnterQueryProc, title=(CurrTitle+":")		SetVariable $("Query_"+JT_Num2DigStr(4,i)), value=$("root:Var_"+CurrName)	 	mVar += 1	 	// Adjust panel size	 	panHeight= yShift+bHeight*mVar+4	 	MoveWindow/W=$pName xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScSc		i += 1	while (i<n) 	Button $("Close_"+pName), pos={4,4+yShift+mVar*bHeight}, size={panWidth-8,32-4}, proc=Close_JT_QueryPanelProc,fColor=(65535/2,65535,65535/2), title="Done"	yShift = 32 	panHeight= yShift+bHeight*mVar+4 	MoveWindow/W=$pName xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScScEndFunction Close_JT_QueryPanelProc(ctrlName) : ButtonControl	String		ctrlName		SVAR		ExecuteUponClosureStr	WAVE/T	JT_QueryWave		// Refresh all values	Variable	n = Numpnts(JT_QueryWave)	Variable	i	i = 0	do		ControlInfo $("Query_"+JT_Num2DigStr(4,i))		SVAR	contentsStr = $(S_Value)		JT_QueryWave[i] = contentsStr		i += 1	while (i<n)		// Close panel	DoWindow/K $(ctrlName[6,strlen(ctrlName)-1])		// If applicable, execute user defined procedure	if (exists("ExecuteUponClosureStr")==2)		if (!(StringMatch(ExecuteUponClosureStr,"")))			Execute ExecuteUponClosureStr		endif	endif	End	Function JT_EnterQueryProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva		NVAR		CMM_HeatmapGamma	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String varStr = sva.sval			String varName = sva.vName			String ctrlName = sva.ctrlName			WAVE/T		JT_QueryWave			print "Entered value for "+varName[4,strlen(varName)-1]+":",varStr			Variable	index = str2num(ctrlName[6,9])			JT_QueryWave[index] = varStr			break		case -1: // control being killed			break	endswitch	return 0End//Function JT_EnterQueryProc(ctrlName,varNum,varStr,varName) : SetVariableControl//	String		ctrlName//	Variable	varNum//	String		varStr//	String		varName//	//	WAVE/T	JT_QueryWave//	//	print "Entered value for "+varName[4,strlen(varName)-1]+":",varStr//	Variable	index = str2num(ctrlName[6,9])//	JT_QueryWave[index] = varStr////End//////////////////////////////////////////////////////////////////////////////////// General make panel procedureFunction JT_MakePanel(pName,pTitle,JT_FuncNames,JT_Titles)	String		pName	String		pTitle	String		JT_FuncNames	String		JT_Titles	Variable		smallPanel = 0		Variable Keys = GetKeyState(0)	if (Keys & 2^3)		smallPanel = 1	endif	Variable	panWidth = 200	Variable	bHeight = 20	Variable	bSpace = bHeight+1	Variable	fontSize = 11	Variable topButtonHeight = 	bHeight*2-4	Variable	yShift = topButtonHeight+2	Variable	sidePad = 4	if (smallPanel)		panWidth = 120		bHeight = 12		bSpace = bHeight+1		topButtonHeight = bHeight		fontSize = 7		yShift = topButtonHeight+2		sidePad = 2	endif	Variable	panHeight= 32+bHeight*3+4		Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	xPos = JT_GetScreenSize()-(panWidth+sidePad*2)	Variable	yPos = 50		if (StrSearch(pTitle,"Misc",0)>0)		xPos -= (panWidth+sidePad)	endif		// If panel already exists, keep it in the same place, please	DoWindow $pName	if (V_flag)		GetWindow $pName, wsize		xPos = V_left/ScSc		yPos = V_top/ScSc	endif		DoWindow /K $pName	NewPanel /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScSc) as pTitle	DoWindow /C $pName 	Button $("Close_"+pName), pos={sidePad,4}, size={panWidth-sidePad*2,topButtonHeight}, proc=Close_JT_PanelProc,fColor=(65535,65535/2,65535/2), title="Close panel",font="Arial",fSize=(fontSize+1),fStyle=1	Variable	mVar = 0		Variable	nButtons = ItemsInList(JT_FuncNames)		if (nButtons!=ItemsInList(JT_Titles))		Abort "Strange error: JT_Titles length ≠ JT_FuncNames length"	endif		String		CurrFunc = ""	String		CurrTitle = ""	Variable	i		i = 0		do		// Figure out current button		CurrFunc = StringFromList(i,JT_FuncNames)		CurrTitle = StringFromList(i,JT_Titles)	 	//Add button		Button $("B_"+CurrFunc), pos={sidePad,4+yShift+mVar*bSpace},size={panWidth-sidePad*2,bHeight}, proc=JT_CallButtonProc, title=CurrTitle,font="Arial",fSize=(fontSize)	 	mVar += 1	 	// Adjust panel size once we know how many buttons are there	 	panHeight= topButtonHeight+4+bSpace*mVar+4	 	MoveWindow/W=$pName xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScSc		i += 1	while (i<nButtons)	End//////////////////////////////////////////////////////////////////////////////////// Show tools panelFunction JT()	DoWindow/K JT_Panel	DoWindow/K JT_Misc_Panel	Make_JT_Panel()	Make_JT_Misc_Panel()	JT_TidyCommandWin()EndFunction JTM()	Make_JT_Misc_Panel()EndFunction JT_GetVmRin()	DoWindow/K getVmRinTable	String		wList = WaveList("*", ";","WIN:")	print		wList	Variable	x1 = xcsr(A)	Variable	x2 = xcsr(B)		make/O/N=(0) getVm,getRin	make/O/T/N=(0) getwName	Variable	n = ItemsInList(wList)	String		currItem	Variable	i	i = 0	do		currItem = StringFromlist(i,wList)		Cursor A,$currItem,x1		Cursor B,$currItem,x2		print currItem,vcsr(A)*1e3,abs(vcsr(B)-vcsr(A))/0.025e-9/1e6		getwName[numpnts(getwName)] = {currItem}		getVm[numpnts(getVm)] = {vcsr(A)*1e3}		getRin[numpnts(getRin)] = {abs(vcsr(B)-vcsr(A))/0.025e-9/1e6}		i += 1	while(i<n)		WaveStats/Q getVm	print V_avg,"±",V_SEM,"mV"	WaveStats/Q getRin	print V_avg,"±",V_SEM,"MOhm"		DoWindow/K getVmRinTable	Edit getVm,getRin as "Get V_m and R_in"	DoWindow/C getVmRinTableEndFunction JT_GetCursorData()	Variable	CsrAOnGraph	Variable	CsrBOnGraph	String		cursorInfo	Variable	pcsrA,pcsrB	cursorInfo = csrInfo(A)	if (StrLen(cursorInfo)==0)		Print "Cursor A is not on a trace."		CsrAOnGraph = 0	else		Print "Cursor A is at x position:",xcsr(A),"\tpoint:",pcsr(A)		pcsrA = pcsr(A)		Make/O/N=(0) JT_csrAwave		CsrAOnGraph = 1	endif	cursorInfo = csrInfo(B)	if (StrLen(cursorInfo)==0)		Print "Cursor B is not on a trace."		CsrBOnGraph = 0	else		Print "Cursor B is at x position:",xcsr(B),"\tpoint:",pcsr(B)		pcsrB = pcsr(B)		Make/O/N=(0) JT_csrBwave		CsrBOnGraph = 1	endif		Make/O/T/N=(0) JT_csrWaveNames	if ((CsrAOnGraph==0) %& (CsrBOnGraph==0))		Beep		Print "You have to have at least one cursor active in the graph!"		Abort "You have to have at least one cursor active in the graph!"	endif		String		GraphList = WinList("*",";","WIN:1")	if (ItemsInList(GraphList)==0)		Abort "No graphs open."	endif	String		NameTop = StringFromList(0,GraphList)	Print		"Working on traces this graph:",NameTop	String		ListOfWaves = TraceNameList(NameTop,";",1)	Variable	nWaves = ItemsInList(ListOfWaves)	Print "Found "+num2str(nWaves)+" waves. These are: "	Print	ListOfWaves	if (nWaves==0)		Abort "No traces in graph."	endif	Variable	i	String		currWave	i = 0	do		currWave = StringFromList(i,ListOfWaves)		WAVE	w = $currWave		JT_csrWaveNames[numpnts(JT_csrWaveNames)] = {currWave}//		Print "\tWorking on: "+currWave		if (CsrAOnGraph)			JT_csrAwave[numpnts(JT_csrAwave)] = {w[pcsrA]}		endif		if (CsrBOnGraph)			JT_csrBwave[numpnts(JT_csrBwave)] = {w[pcsrB]}		endif		i += 1	while (i<nWaves)	if ((CsrAOnGraph) %& (CsrBOnGraph))		Duplicate/O JT_csrAwave,JT_BminusAwave		JT_BminusAwave = JT_csrBwave-JT_csrAwave		DoWindow/K JT_CursorDataTable		Edit/W=(5,44,431,242) JT_csrWaveNames,JT_csrAwave,JT_csrBwave,JT_BminusAwave as "Cursors A&B data table"		DoWindow/C JT_CursorDataTable	else		if (CsrAOnGraph)			DoWindow/K JT_CursorDataTable			Edit/W=(5,44,267,242) JT_csrWaveNames,JT_csrAwave as "Cursor A data table"			DoWindow/C JT_CursorDataTable		endif		if (CsrBOnGraph)			DoWindow/K JT_CursorDataTable			Edit/W=(5,44,267,242) JT_csrWaveNames,JT_csrBwave as "Cursor B data table"			DoWindow/C JT_CursorDataTable		endif	endifEndFunction Make_JT_Misc_Panel()	String		JT_FuncNames,JT_Titles		JT_FuncNames = ""	JT_Titles = ""		JT_FuncNames += "JT_CalcFreq;"	JT_Titles += "Calculate frequency;"		JT_FuncNames += "JT_GetCursorData;"	JT_Titles += "Get cursor data;"		JT_FuncNames += "JT_CountCrossings;"	JT_Titles += "Count crossings;"		JT_FuncNames += "JT_GetVmRin;"	JT_Titles += "Get V_m and R_in;"		JT_FuncNames += "R_in;"	JT_Titles += "Show R_in;"		JT_FuncNames += "V_m;"	JT_Titles += "Show V_m;"		JT_FuncNames += "FitEPSP_30;"	JT_Titles += "Fit EPSP w/ AP @ 30 ms;"		JT_FuncNames += "FitEPSP_10;"	JT_Titles += "Fit EPSP w/ AP @ 10 ms;"		JT_FuncNames += "JT_fitExp;"	JT_Titles += "Fit exponential;"	JT_FuncNames += "JT_PrintAddGaussian;"	JT_Titles += "Add Gaussian;"	JT_FuncNames += "ListToGraph_JT_Traces;"	JT_Titles += "JT_Traces --> Graph;"		JT_FuncNames += "JT_PrintDoTTest;"	JT_Titles += "Student's T test;"		JT_FuncNames += "JT_PrintJT_QuickPaired;"	JT_Titles += "Quick paired T test plot;"		JT_FuncNames += "JT_Printqp;"	JT_Titles += "Quick scatter plot;"	JT_FuncNames += "JT_PrintJT_ScatterWithMeans;"	JT_Titles += "Scatter plot w/ means;"		JT_FuncNames += "JT_PrintJT_BarGraphFDWN;"	JT_Titles += "Quick bar graph;"		JT_FuncNames += "JT_PrintJT_MakeHist;"	JT_Titles += "Quick histogram;"		JT_FuncNames += "JT_Printnw;"	JT_Titles += "Name top window;"		JT_FuncNames += "JT_Mod_fSize;"	JT_Titles += "Modify font size;"	JT_FuncNames += "JT_ExtractSTPData;"	JT_Titles += "Extract STP data;"		JT_FuncNames += "JT_MakeNotebook;"	JT_Titles += "Make notebook;"		JT_FuncNames += "JT_ApplyCommand;"	JT_Titles += "Apply command;"		JT_FuncNames += "JT_MakePTFCPanel;"	JT_Titles += "Plot Cell_## traces;"	JT_FuncNames += "JT_initEnsAvePanel;"	JT_Titles += "Make ensemble average;"		JT_FuncNames += "JT_SetDrawLayer;"	JT_Titles += "Set draw layer;"	JT_FuncNames += "JT_MakeLoadWavesPanel;"	JT_Titles += "Load waves;"		JT_FuncNames += "JT_Prog1;"	JT_Titles += "Prog do-while;"		JT_FuncNames += "JT_Prog2;"	JT_Titles += "Prog if-endif;"		JT_FuncNames += "JT_Prog3;"	JT_Titles += "Prog button function;"		JT_FuncNames += "Make_JT_Panel;"	JT_Titles += "Make Tools panel;"	JT_FuncNames += "Make_JT_Misc_Panel;"	JT_Titles += "Redraw this panel;"		JT_MakePanel("JT_Misc_Panel","J-Misc",JT_FuncNames,JT_Titles)EndFunction JT_Prog1()	String		theStr = "\tVariable\tn = 1\r\tVariable\ti\r\ti = 0\r\tdo\r\t\t\r\t\ti += 1\r\twhile(i<n)\r"	Print "In clipboard:"	Print theStr	PutScrapText theStrEndFunction JT_Prog2()	String		theStr = "\tif\r\t\t\r\telse\r\t\t\r\tendif\r"	Print "In clipboard:"	Print theStr	PutScrapText theStrEndFunction JT_Prog3()	String		theStr = ""	theStr += "Function Proc(ba) : ButtonControl\r"	theStr += "\tSTRUCT WMButtonAction &ba\r"	theStr += "\r"	theStr += "\tswitch( ba.eventCode )\r"	theStr += "\t\tcase 2: // mouse up\r"	theStr += "\t\t\tPrint \"--- CODE HERE ---\"\r"	theStr += "\t\t\tbreak\r"	theStr += "\tendswitch\r"	theStr += "\r"	theStr += "\treturn 0\r"	theStr += "End\r"	Print "In clipboard:"	Print theStr	PutScrapText theStrEndFunction JT_printDataFromTopGraph()	String		traceList =  wavelist("*",";","WIN:")	Variable	nWaves = itemsInList(traceList)	WAVE		dummyW = $(stringFromList(0,traceList))	Variable	nItems = numpnts(dummyW)	Variable	i,j	String		tempStr = ""	String		tempStr2 = ""	i = 0	do		tempStr = ""		tempStr2 = ""		j = nWaves-1		do			if (i==0)				tempStr2 += stringFromList(j,traceList)+" "			endif			if (WaveType($(stringFromList(j,traceList)))==0)				WAVE	/T	w1 = $(stringFromList(j,traceList))				tempStr += w1[i]			else				WAVE		w2 = $(stringFromList(j,traceList))				tempStr += num2str(w2[i])			endif			tempStr += " "			j -= 1		while (j>-1)		tempStr += "\r"		if (i==0)			tempStr2 += "\r"			print tempStr2		endif		print tempStr		i += 1	while(i<nItems)EndFunction Make_JT_Panel()	String		JT_FuncNames,JT_Titles		JT_FuncNames = ""	JT_Titles = ""		JT_FuncNames += "JT_wList;"	JT_Titles += "Wave list;"		JT_FuncNames += "JT_EditTopGraphWaves;"	JT_Titles += "Edit waves in top graph;"	JT_FuncNames += "JT_printDataFromTopGraph;"	JT_Titles += "Print waves in top graph;"	JT_FuncNames += "JT_ExpandTopGraph;"	JT_Titles += "Expand top graph;"	JT_FuncNames += "JT_row2col;"	JT_Titles += "Clipboard row to column;"	JT_FuncNames += "JT_InvertTraceOrder;"	JT_Titles += "Invert trace order;"	JT_FuncNames += "RemoveAxes;"	JT_Titles += "Remove axes;"		JT_FuncNames += "AddAxes;"	JT_Titles += "Add axes;"		JT_FuncNames += "NewSmoothedGraph;"	JT_Titles += "New smoothed graph;"		JT_FuncNames += "MakeBlueWhite;"	JT_Titles += "Blue background + white;"		JT_FuncNames += "MakeBlueCol;"	JT_Titles += "Blue background + color;"		JT_FuncNames += "AlignBaselineAtZero;"	JT_Titles += "Align baseline at zero;"		JT_FuncNames += "AlignBaselineAtMean;"	JT_Titles += "Align baseline at mean;"		JT_FuncNames += "ProduceMeanTrace;"	JT_Titles += "Produce mean trace;"		JT_FuncNames += "CallColorizeTraces1;"	JT_Titles += "Colorize: Oscilloscope preset;"		JT_FuncNames += "CallColorizeTraces6;"	JT_Titles += "Colorize: For publications;"		JT_FuncNames += "CallColorizeTraces2;"	JT_Titles += "Colorize: Red-to-blue;"		JT_FuncNames += "CallColorizeTraces4;"	JT_Titles += "Colorize: Blue-to-red;"		JT_FuncNames += "CallColorizeTraces3;"	JT_Titles += "Colorize: Red-to-green;"		JT_FuncNames += "CallColorizeTraces5;"	JT_Titles += "Colorize: Green-to-red;"		JT_FuncNames += "SmartYAxisRange;"	JT_Titles += "Smart Y axis range;"		JT_FuncNames += "FindRiseTimes;"	JT_Titles += "Find rise times;"		JT_FuncNames += "CopyAxesRanges;"	JT_Titles += "Copy axes ranges;"		JT_FuncNames += "CopyCursorPositions;"	JT_Titles += "Copy cursor positions;"	JT_FuncNames += "ProduceCalibrator;"	JT_Titles += "Produce calibrator;"	JT_FuncNames += "FontIsHelvetica;"	JT_Titles += "Font: Helvetica;"	JT_FuncNames += "MakeStimArtifactPanel;"	JT_Titles += "Remove stim artifacts;"	JT_FuncNames += "JT_gammaCorrectionPanel;"	JT_Titles += "Gamma correction;"	JT_FuncNames += "JT_SpreadTracesInGraph;"	JT_Titles += "Spread traces in graph;"	JT_FuncNames += "JT_GatherTraceNames;"	JT_Titles += "Collect trace names;"	JT_FuncNames += "JT_DuplicateGraph;"	JT_Titles += "Duplicate graph;"	JT_FuncNames += "SaveAllWavesInTopWindow;"	JT_Titles += "Save all waves in top window;"	JT_FuncNames += "JT_SetLineThickness;"	JT_Titles += "Set line thickness;"	JT_FuncNames += "JT_LoadTIFFheader;"	JT_Titles += "Load TIFF header;"	JT_FuncNames += "JT_TidyCommandWin;"	JT_Titles += "Tidy command window;"	JT_FuncNames += "Make_JT_Misc_Panel;"	JT_Titles += "Make Misc panel;"	JT_FuncNames += "Make_JT_Panel;"	JT_Titles += "Redraw this panel;"	JT_MakePanel("JT_Panel","J-Tools",JT_FuncNames,JT_Titles)EndFunction JT_ApplyCommand()		Print "--- Apply command to all waves in graph ---"	Print "\tThe string $$$ will be subsituted for the wave name..."	if (!(exists("Var_Command")))		String/G	Var_Command = "Duplicate/O $$$,$$$_MOD;//JT_Traces+=\"$$$_MOD,\""	endif	JT_MakeQueryPanel("Enter command","Command;","JT_DoApplyCommand()")	End	Function JT_DoApplyCommand()		Print "--- Applying command ---"	SVAR		Var_Command	Print "\tThis is the command:",Var_Command//	String		TraceList = WaveList("*",";","WIN:")	Variable	i//	Variable	n = ItemsInList(TraceList)//	Print "\tFound",n,"items in list."	String topGraphStr = StringFromList(0,WinList("*",";","WIN:1"))	GetWindow $topGraphStr, wavelist	WAVE/T	W_WaveList	Variable nWaves = DimSize(W_WaveList,0)	Print "Number of waves in window "+topGraphStr+":",nWaves	String		currEntry	String		currCommand		i = 0	do		currEntry = W_WaveList[i][1]		if (StringMatch(currEntry[0,0],":"))			currEntry = "root"+W_WaveList[i][1]		else			currEntry = "root:"+W_WaveList[i][1]		endif		currCommand = ReplaceString("$$$",Var_Command,currEntry)		print currCommand		Execute/Q currCommand		i += 1	while(i<nWaves)	End	Function Close_JT_PanelProc(ctrlName) : ButtonControl	String		ctrlName		DoWindow/K $(ctrlName[6,strlen(ctrlName)-1])	End	Function JT_CallButtonProc(ctrlName) : ButtonControl	String		ctrlName		String		CommandStr		CommandStr = ctrlName[2,strlen(ctrlName)-1]+"()"		print CommandStr		Execute CommandStrEnd//////////////////////////////////////////////////////////////////////////////////// Make simple notebookFunction JT_MakeNotebook()	DoWindow JT_Notes	if (!(V_flag))		Print "Making notebook..."		NewNotebook/F=0/K=0/W=(60,60,400,200)/N=JT_Notes as "Notes"	else		Print "Notebook already exists -- bringing to the front..."		DoWindow/F JT_Notes	endifEnd//////////////////////////////////////////////////////////////////////////////////// Make nice histogramFunction JT_MakeHist(wName,numBins,xLabel,Title)	String		wName	Variable	numBins	String		xLabel,Title		String		yLabel = "frequency (%)"		String	modTitle = JT_RemoveSpaces(Title)	WAVE		w = $wName	KillWaves/Z $(wName+"_hist")	Make/O/N=(1) $(wName+"_hist")	WAVE		h = $(wName+"_hist")	h = 0	WaveStats/Q w	Variable	range = (V_max-V_min)*1.5			// expand range a bit	Variable	center = (V_max+V_min)/2	Variable	binStart = center-range/2	Variable	binWidth = range/numBins	Print "Max:",V_max,"Min:",V_min	Print "binStart:",binStart,"binWidth:",binWidth,"nBins:",numBins	Histogram/B={binStart,binWidth,numBins} $wName,$(wName+"_hist")	Variable	TheSum = Sum(h)	h *= 100/TheSum		DoMean($wName)		DoWindow $modTitle	if (V_flag)		DoWindow/F $modTitle	else		DoWindow/K $modTitle		Display $(wName+"_hist") as Title		DoWindow/C $modTitle		ModifyGraph mode=5,lsize=2		ModifyGraph rgb=(0,0,65535)		ModifyGraph fSize=14		SetAxis/A/N=1/E=1 left		SetAxis/A/N=1 bottom		Label bottom,xLabel		Label left,yLabel	endif	End//////////////////////////////////////////////////////////////////////////////////// Make nice histogram with specified binsFunction JT_MakeHistSpecced(wName,binStart,binWidth,numBins,xLabel,Title)	String		wName	Variable	binStart	Variable	binWidth	Variable	numBins	String		xLabel,Title		String		yLabel = "frequency (%)"		String	modTitle = JT_RemoveSpaces(Title)	WAVE		w = $wName	KillWaves/Z $(wName+"_hist")	Make/O/N=(1) $(wName+"_hist")	WAVE		h = $(wName+"_hist")	h = 0	Histogram/B={binStart,binWidth,numBins} $wName,$(wName+"_hist")	Variable	TheSum = Sum(h)	h *= 100/TheSum		DoMean($wName)		DoWindow $modTitle	if (V_flag)		DoWindow/F $modTitle	else		DoWindow/K $modTitle		Display $(wName+"_hist") as Title		DoWindow/C $modTitle		ModifyGraph mode=5,lsize=2		ModifyGraph rgb=(0,0,65535)		ModifyGraph fSize=14		SetAxis/A/N=1/E=1 left		SetAxis/A/N=1 bottom		Label bottom,xLabel		Label left,yLabel	endif	End//////////////////////////////////////////////////////////////////////////////////// Take entries in top table and make scatter plotFunction JT_Tab2Plot(yCol,xCol)	Variable	yCol	Variable	xCol		String	topTableName = WinName(0,2)	Print "Table is:",topTableName	String	TraceList = WaveList("*",";","WIN:"+topTableName)	Variable nWaves = ItemsInList(TraceList)	if ((yCol>nWaves) %| (xCol>nWaves))		Abort "Columns outside range"	endif	String	yStr = StringFromList(yCol,TraceList)	String	xStr = StringFromList(xCol,TraceList)	Print "y axis:",yStr	Print "x axis:",xStr	qp(yStr,xStr)	End//////////////////////////////////////////////////////////////////////////////////// Quick scatter plot of two wavesFunction qp(yStr,xStr)	String	yStr	String	xStr		Variable p = JT_ScatterPlot(yStr,xStr,yStr,xStr,yStr+" vs "+xStr)		Return p	End//////////////////////////////////////////////////////////////////////////////////// Make nice bar graphFunction JT_BarGraph(yWave,xWave,yLabel,SEMWave,Title)	String	yWave,xWave,yLabel,SEMWave,Title	String	modTitle = JT_RemoveSpaces(Title)		DoWindow/K $(modTitle)	print yWave,xWave,yLabel,SEMWave,Title,modTitle	Display $yWave vs $xWave as Title	DoWindow/C $(modTitle)	SetAxis/A/E=1/N=1 left	ModifyGraph lsize=2,hbFill=2	ErrorBars/T=2/L=2 $yWave Y,wave=($SEMWave,$SEMWave)	ModifyGraph rgb=(11229,25040,44409)	Label left,yLabel	ModifyGraph fSize=14//	SetAxis/N=2 left 0,*	SetAxis/A/E=0 leftEndFunction JT_BarGraphFromData(cond1,cond2) // Finagling with naming ensures backwards compatibility with my own prior code	String	cond1	String	cond2	DoWindow/K JT_bar_graph	JT_BarGraphFromDataWithName(cond1,cond2,"JT_temp")	DoWindow/C JT_bar_graphEnd	Function JT_BarGraphFromDataWithName(cond1,cond2,theName)	String		cond1	String		cond2	String		theName	WAVE		w1 = $cond1	WAVE		w2 = $cond2		Make/O/N=(2) $(theName+"_mean"),$(theName+"_SEM")	if (Exists(theName+"_xLabel")==1)		if (numpnts($(theName+"_xLabel"))==2)		// All good, keep this xAxis label wave		endif	else		Make/O/T/N=(2) $(theName+"_xLabel") = {"Use \"Edit waves\rin top graph\"","button to\rchange x labels"}	endif	WAVE		wMean = $(theName+"_mean")	WAVE		wSEM = $(theName+"_SEM")		WaveStats/Q w1	wMean[0]=V_avg	wSEM[0] = V_sdev/sqrt(V_npnts)	WaveStats/Q w2	wMean[1]=V_avg	wSEM[1] = V_sdev/sqrt(V_npnts)		JT_BarGraph(theName+"_mean",theName+"_xLabel",theName+" (units)",theName+"_SEM",theName+" graph")		Variable p = DoTTest(w1,w2)		Return pEnd	Function JT_3BarGraphFromDataWithName(cond1,cond2,cond3,theName)	String		cond1	String		cond2	String		cond3	String		theName	WAVE		w1 = $cond1	WAVE		w2 = $cond2	WAVE		w3 = $cond3		Make/O/N=(3) $(theName+"_mean"),$(theName+"_SEM")	Make/O/T/N=(3) $(theName+"_xLabel") = {cond1,cond2,cond3}	WAVE		wMean = $(theName+"_mean")	WAVE		wSEM = $(theName+"_SEM")		WaveStats/Q w1	wMean[0]=V_avg	wSEM[0] = V_sdev/sqrt(V_npnts)	WaveStats/Q w2	wMean[1]=V_avg	wSEM[1] = V_sdev/sqrt(V_npnts)		WaveStats/Q w3	wMean[2]=V_avg	wSEM[2] = V_sdev/sqrt(V_npnts)		JT_BarGraph(theName+"_mean",theName+"_xLabel",theName+" units",theName+"_SEM",theName+" graph")		JT_quickANOVA(w1,w2,w3)		Variable p1 = DoTTest(w1,w2)	Variable p2 = DoTTest(w1,w3)	Variable p3 = DoTTest(w2,w3)		Make/O/N=(3) JT_pValWave = {p1,p2,p3}		String	modTitle = JT_RemoveSpaces(theName+" graph")	JT_3BarsSigStars(modTitle,JT_p2sigStr(p1),JT_p2sigStr(p2),JT_p2sigStr(p3))	EndFunction JT_4BarGraphFromDataWithName(cond1,cond2,cond3,cond4,theName)	String		cond1	String		cond2	String		cond3	String		cond4	String		theName	WAVE		w1 = $cond1	WAVE		w2 = $cond2	WAVE		w3 = $cond3	WAVE		w4 = $cond4		Make/O/N=(4) $(theName+"_mean"),$(theName+"_SEM")	Make/O/T/N=(4) $(theName+"_xLabel") = {cond1,cond2,cond3,cond4}	WAVE		wMean = $(theName+"_mean")	WAVE		wSEM = $(theName+"_SEM")		WaveStats/Q w1	wMean[0]=V_avg	wSEM[0] = V_sdev/sqrt(V_npnts)	WaveStats/Q w2	wMean[1]=V_avg	wSEM[1] = V_sdev/sqrt(V_npnts)		WaveStats/Q w3	wMean[2]=V_avg	wSEM[2] = V_sdev/sqrt(V_npnts)		WaveStats/Q w4	wMean[3]=V_avg	wSEM[3] = V_sdev/sqrt(V_npnts)		JT_BarGraph(theName+"_mean",theName+"_xLabel",theName+" units",theName+"_SEM",theName+" graph")		JT_quickANOVA4(w1,w2,w3,w4)	End//////////////////////////////////////////////////////////////////////////////////// Make nice bar graph with x-shifted scatter dataFunction JT_BarGraphWithScatter(cond1,cond2,theName,markerSize)	String		cond1	String		cond2	String		theName		Variable		markerSize	WAVE		w1 = $cond1	WAVE		w2 = $cond2		String	modTitle = JT_RemoveSpaces(theName+" graph")	DoWindow $(modTitle)	print modTitle,V_flag		// Create graph if it does not exist		if (V_flag==0)		Variable pVal = JT_BarGraphFromDataWithName(cond1,cond2,theName)		QuickStars(JT_p2sigStr(pVal))				Duplicate/O w1,$("x"+cond1)		Duplicate/O w2,$("x"+cond2)			WAVE		xw1 = $("x"+cond1)		WAVE		xw2 = $("x"+cond2)				AppendToGraph/NCAT w1 vs xw1		ModifyGraph mode($cond1)=3,marker($cond1)=8		ModifyGraph rgb($cond1)=(58652,0,7208)				AppendToGraph/NCAT w2 vs xw2		ModifyGraph mode($cond2)=3,marker($cond2)=8		ModifyGraph rgb($cond2)=(58652,0,7208)	else		DoWindow/F $(modTitle)		WAVE		xw1 = $("x"+cond1)			WAVE		xw2 = $("x"+cond2)	endif	// Change only scatter graph properties if window does exist	// NB! This will lead to a bug if cond1 and/or cond2 traces are manually removed			SetAxis/A left	ModifyGraph msize($cond1)=markerSize	ModifyGraph msize($cond2)=markerSize		doUpdate	JT_autoScatterXSpread(xw1,w1)	xw1 += 0.5	JT_autoScatterXSpread(xw2,w2)	xw2 += 1.5	End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick ANOVAFunction JT_quickANOVA(w1,w2,w3)	WAVE		w1	WAVE		w2	WAVE		w3	Print "=== Bartlett's test for equal variances ==="	StatsVariancesTest/Q w1,w2,w3	WAVE		W_StatsVariancesTest	print "\tBartlett's T:",W_StatsVariancesTest[2]	print "\tCritical:",W_StatsVariancesTest[3]	if (W_StatsVariancesTest[2]<W_StatsVariancesTest[3])		print "T < critical => Homoscedastic (equal variances) => Use the ANOVA p value"	else		print "T > critical => Heteroscedastic (unequal variances) => You may want to use the Welch or Brown-Forsythe ANOVA"	endif	Print "=== ANOVA ==="	StatsANOVA1Test/BF/Q/W w1,w2,w3	WAVE	M_ANOVA1	print "p (ANOVA) = ",M_ANOVA1[2][5]	WAVE	W_ANOVA1BnF	print "\tp (Brown-Forsythe) = ",W_ANOVA1BnF[4]	WAVE	W_ANOVA1Welch	print "\tp (Welch) = ",W_ANOVA1Welch[4]	Print "=== Kruskal-Wallis ==="	StatsKWTest/Q w1,w2,w3	WAVE	W_KWTestResults	print "p (KW) = ",W_KWTestResults[5]	if (JT_waveHasNaNs(w1))		Beep		print "\tWARNING!!! "+NameOfWave(w1)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	if (JT_waveHasNaNs(w2))		Beep		print "\tWARNING!!! "+NameOfWave(w2)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	if (JT_waveHasNaNs(w3))		Beep		print "\tWARNING!!! "+NameOfWave(w3)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	Print "=== end ==="End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick ANOVA, four wavesFunction JT_quickANOVA4(w1,w2,w3,w4)	WAVE		w1	WAVE		w2	WAVE		w3	WAVE		w4	Print "=== Bartlett's test for equal variances ==="	StatsVariancesTest/Q w1,w2,w3,w4	WAVE		W_StatsVariancesTest	print "\tBartlett's T:",W_StatsVariancesTest[2]	print "\tCritical:",W_StatsVariancesTest[3]	if (W_StatsVariancesTest[2]<W_StatsVariancesTest[3])		print "T < critical => Homoscedastic (equal variances) => Use the ANOVA p value"	else		print "T > critical => Heteroscedastic (unequal variances) => You may want to use the Welch or Brown-Forsythe ANOVA"	endif	Print "=== ANOVA ==="	StatsANOVA1Test/BF/Q/W w1,w2,w3,w4	WAVE	M_ANOVA1	print "p (ANOVA) = ",M_ANOVA1[2][5]	WAVE	W_ANOVA1BnF	print "\tp (Brown-Forsythe) = ",W_ANOVA1BnF[4]	WAVE	W_ANOVA1Welch	print "\tp (Welch) = ",W_ANOVA1Welch[4]	Print "=== Kruskal-Wallis ==="	StatsKWTest/Q w1,w2,w3,w4	WAVE	W_KWTestResults	print "p (KW) = ",W_KWTestResults[5]	if (JT_waveHasNaNs(w1))		Beep		print "\tWARNING!!! "+NameOfWave(w1)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	if (JT_waveHasNaNs(w2))		Beep		print "\tWARNING!!! "+NameOfWave(w2)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	if (JT_waveHasNaNs(w3))		Beep		print "\tWARNING!!! "+NameOfWave(w3)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	if (JT_waveHasNaNs(w4))		Beep		print "\tWARNING!!! "+NameOfWave(w3)+" has NaNs in it -- this affects non-parametric p values, so remove all NaNs and run again!"	endif	Print "=== end ==="End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Put significance stars in bar graphsFunction/S JT_p2sigStr(pVal)	Variable	pVal	String		sigStr = ""		if (pVal<0.05)//		sigStr = "*"		sigStr = "∗"	endif			if (pVal<0.01)//		sigStr = "**"		sigStr = "∗∗"	endif			if (pVal<0.001)//		sigStr = "***"		sigStr = "∗∗∗"	endif			Return	sigStr	End// Quick-and-dirty for top graph, leftmost column only...  Function QuickStars(starStr)	String		starStr	String		topWinName = WinName(0,1)		Print "Adding \""+starStr+"\" to \""+topWinName+"\""		JT_3BarsSigStars(topWinName,starStr,"","")End// Add the n:s to the top bar graphFunction JT_AddTheNs(wList)	String	wList		string	paramStr = ""	Variable	r,g,b	Variable	n = itemsInList(wList)	Variable	i,j	i = 0	do		if (ItemsInList(StringFromList(i,wList),",")>0)			paramStr = StringFromList(1,StringFromList(i,wList),",")			WAVE	w = $(StringFromList(0,StringFromList(i,wList),","))		else			paramStr = ""			WAVE	w = $(StringFromList(i,wList))		endif		WaveStats/Q w		if (strLen(paramStr)>0)			r = str2num(StringFromList(0,paramStr,"_"))			g = str2num(StringFromList(1,paramStr,"_"))			b = str2num(StringFromList(2,paramStr,"_"))			SetDrawEnv ycoord= prel,xcoord= bottom,textxjust= 1,fsize= 10,textrgb= (r,g,b)		else			SetDrawEnv ycoord= prel,xcoord= bottom,textxjust= 1,fsize= 10		endif		DrawText 0.5+i,1,num2str(v_npnts)		i += 1	while(i<n)End// Specifically for a bar graph with three barsFunction JT_3BarsSigStars(GrName,leftStr,midStr,rightStr)	String		GrName,leftStr,midStr,rightStr		Variable	midY = 0	Variable	leftY = 0.07	Variable	rightY = 0.07	Variable	Gap = 0.04		if (StrLen(midStr)==0)		leftY = 0		rightY = 0	endif//	DoWindow/F	$GrName//	DoUpdate	SetDrawLayer/W=$GrName/K UserFront	// Left stars	JT_AddSigLines(0.5,1,1.5-Gap,leftY,leftStr,GrName)	// Middle stars	JT_AddSigLines(0.5,1.5,2.5,midY,midStr,GrName)	// Right stars	JT_AddSigLines(1.5+Gap,2,2.5,rightY,RightStr,GrName)End// For any bar graph, add sig stars in 'Str' plus line between 'leftBar' and 'rightBar'Function JT_AddSigStar(GrName,Str,leftBar,rightBar)	String		GrName,Str	Variable	leftBar,rightBar		if (leftBar>rightBar)		Variable	temp = leftBar		leftBar = rightBar		rightBar = temp	endif		Variable	Y = 0	Variable	Gap = 0.04		Variable	x1 = 0.5+leftBar+Gap	Variable	x3 = 0.5+rightBar-Gap	Variable	x2 = (x1+x3)/2	//	DoWindow/F	$GrName	JT_AddSigLines(x1,x2,x3,Y,Str,GrName)End// To manually add a bunch of significance stars and brackets, use this this function// To edit sigMatrix, type "Edit sigMatrix" after the first run (which creates it)Function JT_addStarsAndBrackets(n)	Variable	n				// Number of columns	String		grName = WinName(0,1)	print "Operating on top graph ",grName		ModifyGraph/W=$(grName) swapXY=0		// WARNING! Assumes axes are flipped!		Variable/G JT_SigLinesFlipY = 1		Variable	i,j		WAVE /Z	sigMatrix			// start with row, column has to follow		if (!WaveExists(sigMatrix))		Make/O/N=(n,n) sigMatrix		sigMatrix = 1	endif	JT_AllBarsSigStars(GrName,sigMatrix)		JT_SigLinesFlipY = 0	ModifyGraph/W=$(grName) swapXY=1End// For any bar graph, add sig lines with stars from a sigMatrix// Use this function call like this//	Make/O/N=(n,n) sigMatrix//	sigMatrix = 1//	//	i = 0//	do//		j = i+1//		do//			WAVE	w1 = $(stringFromList(i,wList))//			WAVE	w2 = $(stringFromList(j,wList))//			pVal = DoTTest(w1,w2)//			sigMatrix[i][j] = pVal*(n-1)				// Times n-1 as a Bonferroni-Dunn fix//			j += 1//		while(j<n)//		i += 1//	while(i<n-1)//	JT_AllBarsSigStars(" <<< yourBarGraphNameHere >>> ",sigMatrix)Function JT_AllBarsSigStars(GrName,sigMatrix)	String		GrName	WAVE		sigMatrix		Variable	n = DimSize(sigMatrix,0)	if (n != DimSize(sigMatrix,1))		print "{JT_AllBarsSigStars} SigMatrix is not square. Exiting."		Abort	endif		Make/O/N=(n-1,2*n) JT_OccupiedSpace	JT_OccupiedSpace = 0	Variable	yLoc = 0	Variable	Gap = 0.04	Variable	ySp = 0.05//	SetDrawLayer/W=$GrName/K UserFront			// Clear previous siglines	DrawAction getgroup=JT_sigLinesGroup	if (V_flag)		print "Deleting previous JT_sigLinesGroup"		DrawAction delete=V_startPos,V_endPos	endif		SetDrawEnv gstart,gname=JT_sigLinesGroup	Variable	i,j,k,free	i = 0	do		j = n-1		do			if (sigMatrix[i][j]<0.05)				k = 0				do					Duplicate/O/R=[i,j-1][k] JT_OccupiedSpace,tempW					if (sum(tempW)==0)						free = k						k = Inf					endif					k += 1				while(k<2*n)				yLoc = free*ySp				JT_AddSigLines(0.5+Gap+i,(0.5+Gap+i+0.5-Gap+j)/2,0.5-Gap+j,yLoc,JT_p2sigStr(sigMatrix[i][j]),GrName)				JT_OccupiedSpace[i,j-1][free] = 1			endif			j -= 1		while(j>i)		i += 1	while(i<n-1)	SetDrawEnv gstop,gname=JT_sigLinesGroup		Killwaves/Z JT_OccupiedSpace,tempWEnd// Lower-level code for adding sig stars and linesFunction JT_AddSigLines(x1,x2,x3,y,txt,grName)	Variable		x1,x2,x3,y	String		txt	String		grName		NVAR /Z JT_SigLinesFlipY							// In some scenarios, the user may want to plot the brackets on the other side of the graph	if (!NVAR_Exists(JT_SigLinesFlipY))			// If so, set JT_SigLinesFlipY to True.		Variable/G JT_SigLinesFlipY = 0	endif	// Assume one, two, or three stars	Variable	spcMin = 0.2	Variable	spcMax = 0.6	Variable	spc = spcMin+(StrLen(txt)/3-1)*(spcMax-spcMin)/2		// Note that StrLen("∗") = 3, but StrLen("*") = 1, hence /3 here!	Variable	downStroke = 0.02	Variable	fontSize = 10		if (!(StringMatch(txt,"")))					// No star no lines		SetDrawEnv/W=$grName xcoord= bottom,ycoord= prel,linethick= 1.0,fillpat= 0		if (JT_SigLinesFlipY)			DrawPoly/W=$grName x1,1-(y+downStroke),1,1,{x1,1-(y+downStroke),x1,1-y,x2-spc/2,1-y} // left hook, downstroke going up, to the right		else			DrawPoly/W=$grName x1,y+downStroke,1,1,{x1,y+downStroke,x1,y,x2-spc/2,y} // left hook, downstroke going up, to the right		endif		SetDrawEnv/W=$grName xcoord= bottom,ycoord= prel,linethick= 1.0,fillpat= 0		if (JT_SigLinesFlipY)			DrawPoly/W=$grName x2+spc/2,1-y,1,1,{x2+spc/2,1-y,x3,1-y,x3,1-(y+downStroke)}	// right hook, mid going right, then downstroke		else			DrawPoly/W=$grName x2+spc/2,y,1,1,{x2+spc/2,y,x3,y,x3,y+downStroke}	// right hook, mid going right, then downstroke		endif		if ((StringMatch(txt[0],"n")))			// if "n.s.", don't use Symbol font			SetDrawEnv/W=$grName xcoord= bottom,textxjust= 1,textyjust= 2,fsize= fontSize		else			SetDrawEnv/W=$grName xcoord= bottom,textxjust= 1,textyjust= 1,fsize= fontSize		endif		if (JT_SigLinesFlipY)			SetDrawEnv/W=$grName textrot= 90			DrawText/W=$grName x2,1-(y+0.005),txt		else			DrawText/W=$grName x2,y+0.01,txt		endif		doXOPIdle		doUpdate/W=$grName		doXOPIdle	endifEnd//////////////////////////////////////////////////////////////////////////////////// Make nice graph for triple-paired data//// This takes two input waves, w1, w2, & w3, that are of the same length, n,//// and transforms these to n waves using baseName and plots these as paired//// comparisons for the three conditions cond1, cond2, & cond3.Function JT_MakeTriplePairedPlot(w1,w2,w3,baseName,graphName,graphTitle,cond1,cond2,cond3,yLabel)	WAVE			w1,w2,w3	String		baseName	String		graphName	String		graphTitle	String		cond1,cond2,cond3	String		yLabel		Variable	n = numpnts(w1)	if ( (numpnts(w2)!=n) %|  (numpnts(w3)!=n) )		Print "TransformAxes strange error: n's are different."		Abort "TransformAxes strange error: n's are different."	endif	Variable	i		DoWindow/K $graphName	Display/W=(5,44,187,272) as graphTitle	DoWindow/C $graphName		Make/O/T/N=(3) $(baseName+"label")	WAVE/T	LabelWave = $(baseName+"label")	LabelWave[0] = cond1	LabelWave[1] = cond2	LabelWave[3] = cond3		i = 0	do		Make/O/N=(3) $(baseName+num2str(i+1))		WAVE	wDest = $(baseName+num2str(i+1))		wDest[0] = w1[i]		wDest[1] = w2[i]		wDest[2] = w3[i]		AppendToGraph /W=$graphName $(baseName+num2str(i+1)) vs $(baseName+"label")		i += 1	while(i<n)	ModifyGraph mode=4,marker=8,opaque=1,toMode=-1,rgb=(37466,44055,61823)	ModifyGraph lsize=0.5	ModifyGraph msize=3,mrkThick=1	ModifyGraph fSize=14	SetAxis/A/N=1 left	Label left,yLabel		Variable p1 = DoPairedTTest(w1,w2)	Variable p2 = DoPairedTTest(w1,w3)	Variable p3 = DoPairedTTest(w2,w3)		JT_3BarsSigStars(graphName,JT_p2sigStr(p1),JT_p2sigStr(p2),JT_p2sigStr(p3))	Return	JT_quickANOVA(w1,w2,w3)End//////////////////////////////////////////////////////////////////////////////////// Make nice graph for paired data//// This takes two input waves, w1 & w2, that are of the same length, n,//// and transforms these to n waves using baseName and plots these as paired//// comparisons for the two conditions cond1 & cond2.Function JT_MakePairedPlot(w1,w2,baseName,graphName,graphTitle,cond1,cond2,yLabel)	WAVE		w1,w2	String		baseName	String		graphName	String		graphTitle	String		cond1,cond2	String		yLabel		Variable	n = numpnts(w1)	if (numpnts(w2)!=n)		Print "TransformAxes strange error: n's are different."		Abort "TransformAxes strange error: n's are different."	endif	Variable	i		DoWindow/K $graphName	Display/W=(5,44,187,272) as graphTitle	DoWindow/C $graphName		Make/O/T/N=(2) $(baseName+"label")	WAVE/T	LabelWave = $(baseName+"label")	LabelWave[0] = cond1	LabelWave[1] = cond2		i = 0	do		Make/O/N=(2) $(baseName+num2str(i+1))		WAVE	wDest = $(baseName+num2str(i+1))		wDest[0] = w1[i]		wDest[1] = w2[i]		AppendToGraph /W=$graphName $(baseName+num2str(i+1)) vs $(baseName+"label")		i += 1	while(i<n)	ModifyGraph mode=4,marker=8,opaque=1,toMode=-1,rgb=(37466,44055,61823)	ModifyGraph lsize=0.5	ModifyGraph msize=3,mrkThick=0.5	ModifyGraph fSize=14	SetAxis/A/N=1 left	Label left,yLabel		Return DoPairedTTest(w1,w2)EndFunction JT_QuickPaired(w1,w2)	WAVE		w1,w2		String		n1 = NameOfWave(w1)	String		n2 = NameOfWave(w2)		return JT_MakePairedPlot(w1,w2,"JT_bName_","QuickPairedGraph","QuickPairedGraph",n1,n2,"units")EndFunction JT_QuickPairedWithMeans(w1,w2)	WAVE		w1,w2		String		n1 = NameOfWave(w1)	String		n2 = NameOfWave(w2)		Variable		pVal = JT_MakePairedPlot(w1,w2,"JT_bName_","QuickPairedGraph","QuickPairedGraph",n1,n2,"units")	JT_quickAddMeans(w1,w2,"JT_bName_")	return pValEnd//////////////////////////////////////////////////////////////////////////////////// Add means to triple paired scatter plotFunction JT_quickAddTripleMeans(w1,w2,w3,baseName)	WAVE		w1,w2,w3	String	baseName	WAVE/T		JT_bName_label = $(baseName+"label")	Make/O/N=(3) $(baseName+"wMeans"),$(baseName+"wSEMs")	WAVE	JT_wMeans = $(baseName+"wMeans")	WAVE	JT_wSEMs = $(baseName+"wSEMs")	WaveStats/Q w1	JT_wMeans[0] = V_avg	JT_wSEMs[0] = V_SEM	WaveStats/Q w2	JT_wMeans[1] = V_avg	JT_wSEMs[1] = V_SEM	WaveStats/Q w3	JT_wMeans[3] = V_avg	JT_wSEMs[3] = V_SEM	DoUpdate	AppendToGraph JT_wMeans vs JT_bName_label	ModifyGraph mode=4,marker($(baseName+"wMeans"))=19,rgb($(baseName+"wMeans"))=(0,0,0)	ModifyGraph msize($(baseName+"wMeans"))=6,mrkThick($(baseName+"wMeans"))=1	ModifyGraph lsize($(baseName+"wMeans"))=2	ErrorBars/T=2/L=2 $(baseName+"wMeans") Y,wave=($(baseName+"wSEMs"),$(baseName+"wSEMs"))End//////////////////////////////////////////////////////////////////////////////////// Add means to paired scatter plotFunction JT_quickAddMeans(w1,w2,baseName)	WAVE		w1,w2	String	baseName	WAVE/T		JT_bName_label = $(baseName+"label")	Make/O/N=(2) $(baseName+"wMeans"),$(baseName+"wSEMs")	WAVE	JT_wMeans = $(baseName+"wMeans")	WAVE	JT_wSEMs = $(baseName+"wSEMs")	WaveStats/Q w1	JT_wMeans[0] = V_avg	JT_wSEMs[0] = V_SEM	WaveStats/Q w2	JT_wMeans[1] = V_avg	JT_wSEMs[1] = V_SEM	DoUpdate	AppendToGraph JT_wMeans vs JT_bName_label	ModifyGraph mode=4,marker($(baseName+"wMeans"))=19,rgb($(baseName+"wMeans"))=(0,0,0)	ModifyGraph msize($(baseName+"wMeans"))=6,mrkThick($(baseName+"wMeans"))=1,lsize($(baseName+"wMeans"))=2	ErrorBars/T=2/L=2 $(baseName+"wMeans") Y,wave=($(baseName+"wSEMs"),$(baseName+"wSEMs"))End//////////////////////////////////////////////////////////////////////////////////// Make nice scatter plotFunction JT_ScatterPlot(yWave,xWave,yLabel,xLabel,Title)	String	yWave,xWave,yLabel,xLabel,Title		String	modTitle = JT_RemoveSpaces(Title)		DoWindow/K $(modTitle)	Display $yWave vs $xWave as Title	DoWindow/C $(modTitle)	ModifyGraph mode=3,marker=8,rgb=(0,0,65535)//	ModifyGraph opaque=1	ModifyGraph fSize=14	Label bottom,xLabel	Label left,yLabel	DoUpdate	CurveFit/Q/X=1 line $yWave /X=$xWave /D	WAVE		W_coef	Print "y="+num2str(W_coef[1])+"*x+"+num2str(W_coef[0])	ModifyGraph lstyle($("fit_"+yWave))=11,lsize($("fit_"+yWave))=2//	print "r=",V_pr	Variable p = JT_DoPearsons(yWave,xWave)	Legend /J/F=0/B=1 yWave+" vs "+xWave+"\rr="+num2str(Round(V_Pr*1000)/1000)+"\rp="+num2str(Round(p*10000)/10000)		Return pEnd//////////////////////////////////////////////////////////////////////////////////// Do t-test on Pearson's rFunction JT_DoPearsons(yWave,xWave)	String		yWave,xWave				// this test is symmetric (as opposed to linear regression) so which is x and which is y doesn't matter//	Print "Doing Pearsons test on ",yWave,"and",xWave,"."	// Igor's built-in Pearsons test does not work on waves which contain NaNs, so remove these from BOTH waves	Variable	i	Duplicate/O $xWave,JT_xTemp	Duplicate/O $yWave,JT_yTemp	// Remove if NaN in xWave	i = 0	do		if (StringMatch(num2str(JT_xTemp[i]),"NaN"))			DeletePoints i,1,JT_xTemp,JT_yTemp		else			i += 1		endif	while(i<numpnts(JT_xTemp))	// Remove if NaN in yWave	i = 0	do		if (StringMatch(num2str(JT_yTemp[i]),"NaN"))			DeletePoints i,1,JT_xTemp,JT_yTemp		else			i += 1		endif	while(i<numpnts(JT_yTemp))	// Do the test	StatsLinearCorrelationTest/Q/Z JT_yTemp,JT_xTemp		// Add  /T=1 to produce a table	WAVE		W_StatsLinearCorrelationTest	Variable/G	JT_PearsonR = W_StatsLinearCorrelationTest[1]	Variable	t_Value = W_StatsLinearCorrelationTest[5]	Variable	n_Value = W_StatsLinearCorrelationTest[0]	Variable/G	JT_pPearson = 1-StudentA(t_Value, n_Value-2)			// This is two-tailed!	Print "StatPearsonTest: r=",JT_PearsonR,"p=",JT_pPearson		Return		JT_pPearsonend//////////////////////////////////////////////////////////////////////////////////// Do t-test on Spearman's rhoFunction JT_DoSpearmans(yWave,xWave)	String		yWave,xWave				// this test is symmetric (as opposed to linear regression) so which is x and which is y doesn't matter	// Igor's built-in Pearsons test does not work on waves which contain NaNs, so remove these from BOTH waves	Variable	i	Duplicate/O $xWave,JT_xTemp	Duplicate/O $yWave,JT_yTemp	// Remove if NaN in xWave	i = 0	do		if (StringMatch(num2str(JT_xTemp[i]),"NaN"))			DeletePoints i,1,JT_xTemp,JT_yTemp		else			i += 1		endif	while(i<numpnts(JT_xTemp))	// Remove if NaN in yWave	i = 0	do		if (StringMatch(num2str(JT_yTemp[i]),"NaN"))			DeletePoints i,1,JT_xTemp,JT_yTemp		else			i += 1		endif	while(i<numpnts(JT_yTemp))	// Do the test	StatsRankCorrelationTest/Q/Z JT_yTemp,JT_xTemp		// Add  /T=1 to produce a table	WAVE		W_StatsRankCorrelationTest	Variable/G	JT_SpearmansRho = W_StatsRankCorrelationTest[4]	Variable	n_Value = W_StatsRankCorrelationTest[0]	Variable/G	JT_pSpearman = 1-statsspearmanrhocdf(abs(JT_SpearmansRho),n_Value)			// This is two-tailed!	Print "StatSpearmanTest: rho=",JT_SpearmansRho,"p=",JT_pSpearman		Return		JT_pSpearmanend//////////////////////////////////////////////////////////////////////////////////// Remove the data points in the list from the numerical wave//// Resulting wave has suffix "_mod"//// Does not work with a text waveFunction JT_RemoveDataPoints(theWave,theList)	WAVE		theWave	String		theList		Duplicate/O	theWave,$(NameOfWave(theWave)+"_mod")	WAVE		modifiedWave = $(NameOfWave(theWave)+"_mod")		Variable	n = itemsInList(theList)	Variable	currItem	Variable	i	if (n>0)		i = 0		do			currItem = str2num(stringFromList(i,theList))			modifiedWave[currItem] = NaN			i += 1		while(i<n)	endif		JT_RemoveNaNs(modifiedWave)	End//////////////////////////////////////////////////////////////////////////////////// Based on a pair of x/y waves, produces a single smoothed running averageFunction JT_SmoothOverXY(xWave,yWave,winSize,minusPad,plusPad)	WAVE		xWave,yWave	Variable	winSize	Variable	minusPad	Variable	plusPad		WaveStats/Q xWave	Variable xStart = V_min-minusPad	Variable xEnd = V_max	Variable n = xEnd-xStart+plusPad	Variable nPoints = numpnts(xWave)	Make/O/N=(n) $(nameOfWave(yWave)+"_Smoothed")	WAVE smoothY = $(nameOfWave(yWave)+"_Smoothed")	SetScale/P x,xStart,1,smoothY	print "Creating "+nameOfWave(yWave)+"_Smoothed"	Variable	i,j,currX	i = 0	do		currX = xStart+i		Make/O/N=(0) workWave		j = 0		do			if ( (xWave[j]>currX-winSize/2) %& (xWave[j]<currX+winSize/2) )				workWave[numpnts(workWave)] = {yWave[j]}			endif			j += 1		while(j<nPoints)		if (numpnts(workWave)>0)			WaveStats/Q workWave			smoothY[i] = V_avg		else			smoothY[i] = NaN		endif		i += 1	while(i<n)End//////////////////////////////////////////////////////////////////////////////////// Make nice scatter plot with means, suitable for CV analysisfunction JT_ScatterWithMeans(yW,xW)	WAVE	yW,xW		if (numpnts(xW)!=numpnts(yW))		print "Both waves must consist of the same number of points!"		Abort "Both waves must consist of the same number of points!"	endif	DoWindow/K JT_SWM_Gr	Display yW vs xW as "Scatter Plot"	DoWindow/C JT_SWM_Gr	ModifyGraph mode=3,marker=8		Make/O/N=(2) wJT_xMean,wJT_xSEM	Make/O/N=(2) wJT_yMean,wJT_ySEM	wJT_xMean = 1	wJT_xSEM = NaN	wJT_yMean = 1	wJT_ySEM = NaN		WaveStats/Q xW	wJT_xMean[0] = V_avg	wJT_xSEM[0] = V_sdev/sqrt(V_npnts)	WaveStats/Q yW	wJT_yMean[0] = V_avg	wJT_ySEM[0] = V_sdev/sqrt(V_npnts)	AppendToGraph/W=JT_SWM_Gr wJT_yMean vs wJT_xMean	ModifyGraph mode(wJT_yMean)=4,marker(wJT_yMean)=19	ErrorBars wJT_yMean XY,wave=(wJT_xSEM,wJT_xSEM),wave=(wJT_ySEM,wJT_ySEM)		ModifyGraph width={Aspect,1}	Print "Aspect ratio is fixed -- to reset, type ModifyGraph width=0"	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// For a given p value, return the appropriate number of significance stars.//// The number of comparisons, nComparisons, is for applying the Bonferroni-Dunn post-hoc correction for//// multiple comparisons. Note that this correction has low power. To not use it, simply pass 1 as an argument.Function/S JT_p2star(p,nComparisons)	Variable	p,nComparisons		String		Stars = ""		//	0.05,0.01,0.001	if (p<0.001/nComparisons)			Stars = "***"	else		if (p<0.01/nComparisons)				Stars = "**"		else			if (p<0.05/nComparisons)					Stars = "*"			endif		endif	endif		Return	Stars	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Produces a global variable unless it already exists. This way, old variable values won't be over-written, when using a//// new version of the jMini procedures.Function JT_GlobalVariable(VarName,NumValue,StrValue,StrFlag)	String		VarName							// Name of variable	Variable	NumValue							// If numerical, its value	String		StrValue							// If string, its value	Variable	StrFlag								// Boolean: Variable is a string		if (!exists(VarName))		if (StrFlag)			String/G	$VarName = StrValue		else			Variable/G	$VarName = NumValue		endif		printf "1"	else		printf "0"	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// This function calculates the mean of a wave but ignores all values that are NaN (Not a Number). The normal Igor function//// called 'mean' returns NaN if any of the values in the wave were NaN, and I think that blows big time.Function JT_MeanIgnoreNaN(TheWave,IndexStart,IndexEnd)	WAVE		TheWave	Variable	IndexStart,IndexEnd			Variable	i	Variable	Count	Variable	TheMean		TheMean = 0	Count = 0	i = 0	do		if (numtype(TheWave[IndexStart+i])==0)			TheMean += TheWave[IndexStart+i]			Count += 1		endif		i += 1	while (i<IndexEnd-IndexStart+1)		TheMean /= Count		Return TheMeanEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// This function calculates the SUM of a wave but ignores all values that are NaN (Not a Number). The normal Igor function//// called 'sum' returns NaN if any of the values in the wave were NaN, and I think that TOO blows big time.Function JT_SumIgnoreNaN(theWave,IndexStart,IndexEnd)	WAVE		TheWave	Variable	IndexStart,IndexEnd			Variable	i	Variable	Count	Variable	TheSum		TheSum = 0	Count = 0	i = 0	do		if (numtype(TheWave[IndexStart+i])==0)			TheSum += TheWave[IndexStart+i]			Count += 1		endif		i += 1	while (i<IndexEnd-IndexStart+1)		Return TheSumEndFunction JT_RemoveNaNs(theWave)	WAVE		theWave		Variable	i		i = 0	do		if (JT_isNaN(theWave[i]))			DeletePoints i,1,theWave		else			i += 1		endif	while(i<numpnts(theWave))EndFunction JT_NaNsBecomeZero(theWave)	WAVE		theWave		Variable	i		i = 0	do		if (JT_isNaN(theWave[i]))			theWave[i] = 0		endif		i += 1	while(i<numpnts(theWave))EndFunction JT_waveHasNaNs(theWave)	WAVE		theWave		Variable	i	Variable	n = numpnts(theWave)	Variable	hasNaN = 0		i = 0	do		if (JT_isNaN(theWave[i]))			hasNaN = 1			i = Inf		endif		i += 1	while(i<numpnts(theWave))		Return	hasNaN	EndFunction JT_isNaN(theNumber)	Variable	theNumber		Return StringMatch(num2str(theNumber),"NaN")	EndFunction/S JT_RemoveSpaces(str)	String	str		Variable	i	i = 0	do		if (StringMatch(str[i,i]," "))			str[i,i]="_"		endif		i += 1	while(i<strlen(str))		Return str	endFunction/S JT_ScoreSpaceKillComma(Str)	String		Str		String		NewStr = Str	Variable	i		i = 0	do		if (StringMatch(NewStr[i]," "))			NewStr[i,i] = "_"		endif		if (StringMatch(NewStr[i],","))			NewStr = NewStr[0,i-1]+NewStr[i+1,StrLen(NewStr)]			i -= 1		endif		i += 1	while (i<StrLen(NewStr))	Return		NewStrEndFunction/S JT_ZapGremlins(str)	String		str	Variable	nChars = StrLen(str)		String		Gremlins = " -,;:/\|~[]{}()@#$%^&=?"	Variable	nGremlins = StrLen(Gremlins)	String		replaceStr = "_"//	Print		"Zapping these gremlins: \""+Gremlins+"\" and replacing with \""+replaceStr+"\""		Variable	i,j	i = 0	do		j = 0		do			if (StringMatch(str[i,i],Gremlins[j,j]))				str[i,i]=replaceStr			endif			j += 1		while(j<nGremlins)		i += 1	while(i<nChars)		Return str	endFunction/S JT_ZapCRs(str)	String		str		Variable	n = strLen(str)	Variable	i	i = 0	do		if (StringMatch(str[i,i],"\r"))			str[i,i] = " "		endif		i += 1	while(i<n)		Return strEnd//////////////////////////////////////////////////////////////////////////////////// Set the draw layer for top graphFunction JT_SetDrawLayer()	DoWindow/B JT_Panel	DoWindow/B JT_Misc_Panel	DoUpdate	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the shift key -- Draw layer is UserFront"		SetDrawLayer UserFront//		Execute "SetDrawLayer UserFront"	else		Print "Draw layer is UserBack"		SetDrawLayer UserBack//		Execute "SetDrawLayer UserBack"	endif	DoWindow/F JT_Panel	DoWindow/F JT_Misc_PanelEnd//////////////////////////////////////////////////////////////////////////////////// Produce wavelistFunction JT_wList()	String		TraceList	String		currEntry	Variable	nWaves	String		SeparatorStr = ","	Variable	i	if (WaveExists(WaveRefIndexed(WinName(0,3),0,3)))		WAVE	w = WaveRefIndexed(WinName(0,3),0,3)		print "Data folder of first trace:",GetWavesDataFolder(w,1)	endif	Variable	OnlyOneAxis = 0	String		AxisStr	Variable Keys = GetKeyState(0)	if (Keys & 2^5)		Print "You pressed the Esc key -- Producing list with ; as a separator instead"		SeparatorStr = ";"	endif	if (Keys & 2^1)		Print "You pressed the Alt key -- This lists all instances of all waves from top graph or table."		if (StringMatch(WinName(0,2),WinName(0,3)))	// Top window is a table			nWaves = ItemsInList(wavelist("*",";","WIN:"))			Print "Number of waves in window "+WinName(0,3)+":",nWaves			print wavelist("*",";","WIN:")		else													// Top window is a graph			GetWindow $WinName(0,3), wavelist			WAVE/T	W_WaveList			nWaves = DimSize(W_WaveList,0)			Print "Number of waves in window "+WinName(0,3)+":",nWaves			i = 0			do				currEntry = W_WaveList[i][1]				if (StringMatch(currEntry[0,0],":"))					print "root"+W_WaveList[i][1]				else					print "root:"+W_WaveList[i][1]				endif				i += 1			while(i<nWaves)		endif	else			if (Keys & 2^2)			Print "You pressed the Shift key -- Getting waves from left axis only."			AxisStr = "left"			OnlyOneAxis = 1		else			if (Keys & 2^0)				Print "You pressed the Command key -- Getting waves from right axis only."				AxisStr = "right"				OnlyOneAxis = 1			endif		endif			TraceList = TraceNameList("",SeparatorStr,1)		nWaves = ItemsInList(TraceList,SeparatorStr)		String		currWave			if (OnlyOneAxis)				Variable	waveCounter = 0			String		NewList = ""			i = 0			do				currWave = StringFromList(i,TraceList,SeparatorStr)				if (StringMatch(WhichYAxis(currWave),AxisStr))					NewList += currWave+SeparatorStr					waveCounter += 1				endif				i += 1			while(i<nWaves)				Print "Number of waves on the "+AxisStr+" axis in window "+WinName(0,1)+":",waveCounter			Print NewList[0,StrLen(NewList)-2]			Print "\r"			else				Print "Listing all waves in graph."			Print "Number of waves in window "+WinName(0,1)+":",nWaves			Print TraceList[0,StrLen(TraceList)-2]			Print "\r"			endif	endifEnd//////////////////////////////////////////////////////////////////////////////////// Name top windowFunction JT_NameWin(wName,wTitle)	String	wName	String	wTitle	DoWindow/C $wName	DoWindow/T $wName,wTitleEndFunction nw(nameStr)	String	nameStr		String	noSpacesStr = JT_RemoveSpaces(nameStr)		JT_NameWin(noSpacesStr,nameStr)EndFunction kw(nameStr)	String	nameStr		String	noSpacesStr = JT_RemoveSpaces(nameStr)		DoWindow/K $noSpacesStrEnd//////////////////////////////////////////////////////////////////////////////////// Remove all axes in top graphFunction RemoveAxes()	ModifyGraph noLabel=2,axThick=0EndFunction AddAxes()	ModifyGraph noLabel=0,axThick=1End//////////////////////////////////////////////////////////////////////////////////// Find risetime of EPSPs in traces in top graphFunction FindRiseTimes()	String		Name = WinName(0,1)		Print "--- Find rise times in window "+Name+" ---"		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		GetAxis/W=$Name /Q bottom	Variable	xMin = V_min	Variable	xMax = V_max		Variable	MaxLoc,MaxVal	Variable	MinLoc,MinVal	Variable	EPSPMagn	Variable	At10_x//,At20_y	Variable	At20_x,At20_y	Variable	At80_x,At80_y		Variable	i		Variable	yOffset	Variable	xOffset		Make/O/N=(1) JT_RiseTimePoints_y,JT_RiseTimePoints_x,JT_RT,JT_Amp,JT_at20	JT_RT = NaN	JT_Amp = NaN	JT_at20 = NaN	Variable	RiseTimePointsCounter = 0	Variable	Found_JT_RiseTimePoints = 0	Variable/G	JT_RiseTime = 0		i = 0	do		currWave = StringFromList(i,TraceList)		if (!StringMatch(currWave,"JT_RiseTimePoints_y"))			yOffset = ReadYOffset(currWave)			xOffset = ReadXOffset(currWave)				Duplicate/O $currWave,JT_tempWave			JT_tempWave[x2pnt(JT_tempWave, xMax-xOffset)+1,]=JT_tempWave[x2pnt(JT_tempWave, xMax-xOffset)] // Avoid end effects when smoothing			JT_tempWave[,x2pnt(JT_tempWave, xMin-xOffset)-1]=JT_tempWave[x2pnt(JT_tempWave, xMin-xOffset)]			Smooth/B 7,JT_tempWave			WaveStats/Q/R=(xMin-xOffset,xMax-xOffset) JT_tempWave				// Peak location			MaxLoc = V_maxloc			MaxVal = V_max				WaveStats/Q/R=(xMin-xOffset,MaxLoc) JT_tempWave				// Find baseline (min location)			MinLoc = V_minloc			MinVal = V_min						EPSPMagn = MaxVal-MinVal								// EPSP size						FindLevel/Q/R=(MaxLoc,xMin-xOffset) JT_tempWave,(MinVal+EPSPMagn*0.2)	// Find 20%			At20_x = V_LevelX			At20_y = JT_tempWave(At20_x)				FindLevel/Q/R=(MaxLoc,xMin-xOffset) JT_tempWave,(MinVal+EPSPMagn*0.8)	// Find 80%			At80_x = V_LevelX			At80_y = JT_tempWave(At80_x)						FindLevel/Q/R=(MaxLoc,xMin-xOffset) JT_tempWave,(MinVal+EPSPMagn*0.1)	// Find 10%			At10_x = V_LevelX//			At80_y = JT_tempWave(At80_x)						JT_RiseTimePoints_y[RiseTimePointsCounter] = {MinVal+yOffset,At20_y+yOffset,At80_y+yOffset,MaxVal+yOffset,NaN}			JT_RiseTimePoints_x[RiseTimePointsCounter] = {MinLoc+xOffset,At20_x+xOffset,At80_x+xOffset,MaxLoc+xOffset,NaN}			RiseTimePointsCounter += 5						print "\t"+currWave+" -- Rise time is: ",(At80_x-At20_x)*1e3," ms","EPSP amplitude is:",EPSPMagn*1e3,"mV"			JT_RiseTime = (At80_x-At20_x)*1e3			JT_RT[numpnts(JT_RT)] = {JT_RiseTime}			JT_Amp[numpnts(JT_Amp)] = {EPSPMagn}			JT_at20[numpnts(JT_at20)] = {At20_x}		else			Found_JT_RiseTimePoints = 1		endif		i += 1	while(i<nWaves)		if (!(Found_JT_RiseTimePoints))		AppendToGraph/W=$Name JT_RiseTimePoints_y vs JT_RiseTimePoints_x	endif	ModifyGraph mode(JT_RiseTimePoints_y)=4,marker(JT_RiseTimePoints_y)=8	print "Crossing 10% at x=",At10_x," for last trace."End//////////////////////////////////////////////////////////////////////////////////// Set Y axis range to min and max of current wavesFunction SmartYAxisRange()	String		Name = WinName(0,1)		Print "--- Set Y axis range to smart values in window "+Name+" ---"		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		GetAxis/W=$Name /Q bottom	Variable	xMin = V_min	Variable	xMax = V_max		Variable	yMax = -Inf	Variable	yMin = Inf		Variable	doSmooth = 0	Variable Keys = GetKeyState(0)	if (Keys & 4)		Print "You pressed the Shift key -- using smoothed wave."		doSmooth = 1	endif		String	AxisStr = "left"	if (Keys & 1)		Print "You pressed the Command key -- using working on the right axis instead of the left axis."		AxisStr = "right"	endif		Variable	i		Variable	xOffset,yOffset		i = 0	do		currWave = StringFromList(i,TraceList)		if (StringMatch(WhichYAxis(currWave),AxisStr))			// print "\tWorking on:",currWave			xOffset = ReadXOffset(currWave)			yOffset = ReadYOffset(currWave)			if (doSmooth)				Duplicate/O $currWave,JT_dumWave				Smooth/B 25,JT_dumWave				WaveStats/Q/R=(xMin-xOffset,xMax-xOffset)/Z JT_dumWave			else				WaveStats/Q/R=(xMin-xOffset,xMax-xOffset)/Z $currWave			endif			if (yMax<V_max+yOffset)				yMax = V_max+yOffset			endif			if (yMin>V_min+yOffset)				yMin = V_min+yOffset			endif		endif		i += 1	while(i<nWaves)	Variable	wHeight = 0	Variable	adj = 0	if (doSmooth)		wHeight = yMax-yMin		adj = 0.03*wHeight	endif	SetAxis/Z/W=$Name $AxisStr,yMin-adj,yMax+adj		KillWaves/Z JT_DumWaveEndFunction/S WhichYAxis(wName)	String		wName	String		InfoStr = TraceInfo("",wName,0)	String		ExtrStr = StringByKey("YAXIS",InfoStr,":",";")	Return		ExtrStrEndFunction ReadYOffset(wName)	String		wName	String		InfoStr = TraceInfo("",wName,0)	String		ExtrStr = StringByKey("offset(x)",InfoStr,"=",";")	Variable	xOffset,yOffset	sscanf		ExtrStr,"{%f,%f}", xOffset, yOffset	Return		yOffsetEndFunction ReadXOffset(wName)	String		wName	String		InfoStr = TraceInfo("",wName,0)	String		ExtrStr = StringByKey("offset(x)",InfoStr,"=",";")	Variable	xOffset,yOffset	sscanf		ExtrStr,"{%f,%f}", xOffset, yOffset	Return		xOffsetEnd//////////////////////////////////////////////////////////////////////////////////// Take all traces in top graph & change their line thickness according to keys pressed by userFunction JT_SetLineThickness()	Variable	thick = 2		String		Name = WinName(0,1)		Print "--- Setting line thickness in graph "+Name+" ---"		Variable Keys = GetKeyState(0)	if (Keys & 2^2)		thick *= 0.5	endif	if (Keys & 2^0)		thick *= 3	endif		Print "Line thickness = ",thick		ModifyGraph lsize=(thick) End//////////////////////////////////////////////////////////////////////////////////// Take all traces in top graph, duplicate the traces, smooth them, and make a new graph...Function NewSmoothedGraph()	Variable	smoothVal	= 7	DoWindow/K	JS_SmoothedGraph			// First get rid of previous Smoother Graph!	String		Name = WinName(0,1)		Print "--- Smoothing all traces found in "+Name+" ---"		Variable Keys = GetKeyState(0)	if (Keys & 4)		SmoothVal *= 2	endif	if (Keys & 1)		SmoothVal *= 3	endif	if (Keys & 16)		SmoothVal = Floor(SmoothVal/2)	endif		Print "SmoothVal = ",SmoothVal	String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Make/O		colWaveR = {65535,65535,00000,00000,65535,00000}	Make/O		colWaveG = {65535,00000,65535,00000,00000,65535}	Make/O		colWaveB = {00000,00000,00000,65535,65535,65535}		Variable	nCols = numpnts(colWaveR)		Display as "Smoothed traces"	DoWindow/C	JS_SmoothedGraph		Variable	i		i = 0		do		currWave = StringFromList(i,TraceList)		print "\tWorking on:",currWave		Duplicate/O $currWave,$(currWave+"_Sm")		WAVE	w = $(currWave+"_Sm")		Smooth/B smoothVal,w		AppendToGraph/W=JS_SmoothedGraph $(currWave+"_Sm")		ModifyGraph RGB($(currWave+"_Sm"))=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		i += 1	while (i<nWaves)	ModifyGraph lsize=2	ModifyGraph fSize=18		Print "--- Done ---"End//////////////////////////////////////////////////////////////////////////////////// Prepare top graph for PowerPoint presentation by making background blueFunction MakeBlueWhite()	MakeBlue(1)EndFunction MakeBlueCol()	MakeBlue(0)EndFunction MakeBlue(allWhite)	Variable	allWhite	Variable Keys = GetKeyState(0)	if (Keys & 16)		MakeBW(allWhite)		Return 0	endif	String		Name = WinName(0,1)	Print "--- Making \""+Name+"\" blue ---"	if (Keys & 4)		Print "You pressed the Shift key -- altering background hue of blue."		ModifyGraph wbRGB=(0,25/256*65535,160/256*65535),gbRGB=(0,25/256*65535,160/256*65535)	else		if (Keys & 1)			Print "You pressed the Command key -- background is now black."			ModifyGraph wbRGB=(0,0,0),gbRGB=(0,0,0)		else			ModifyGraph wbRGB=(0,0,65535),gbRGB=(0,0,65535)		endif	endif		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Make/O		colWaveR = {59136,26880,65280,00000, 65535,00000,29952,36873}	Make/O		colWaveG = {54784,43776,29952,65535, 00000,00000,29952,14755}	Make/O		colWaveB = {01280,64512,65280,00000, 00000,00000,29952,58982}		Variable	nCols = numpnts(colWaveR)		Variable	i		String		legendList = AnnotationList(Name)	Variable	nLegends = ItemsInList(legendList)	String		currLegend	if (nLegends>0)		i = 0		do			currLegend = StringFromList(i,legendList)			Legend/C/N=$currLegend/J/B=3/G=(65535,65535,65278)			i += 1		while (i<nLegends)	endif	i = 0	do		currWave = StringFromList(i,TraceList)		print "\tWorking on:",currWave		WAVE	w = $currWave		if ((i>nCols-1) %| (allWhite))			ModifyGraph RGB($currWave)=(65535,65535,65278)		else			ModifyGraph RGB($currWave)=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		endif		ModifyGraph lsize($currWave)=2//		ModifyGraph lstyle=0		i += 1	while (i<nWaves)	//	ModifyGraph fSize=18	ModifyGraph opaque=0	ModifyGraph axRGB=(65535,65535,65278)	ModifyGraph tlblRGB=(65535,65535,65278)	ModifyGraph alblRGB=(65535,65535,65278)	Print "--- Done ---"EndFunction MakeBW(allBlack)	Variable	allBlack	String		Name = WinName(0,1)		Print "--- Making \""+Name+"\" have white background ---"	ModifyGraph wbRGB=(65535,65535,65535),gbRGB=(65535,65535,65535)		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		Make/O		colWaveR = {59136,26880,65280,00000, 65535,00000,29952,36873}	Make/O		colWaveG = {54784,43776,29952,65535, 00000,00000,29952,14755}	Make/O		colWaveB = {01280,64512,65280,00000, 00000,00000,29952,58982}		Variable	nCols = numpnts(colWaveR)		Variable	i		String		legendList = AnnotationList(Name)	Variable	nLegends = ItemsInList(legendList)	String		currLegend	if (nLegends>0)		i = 0		do			currLegend = StringFromList(i,legendList)			Legend/C/N=$currLegend/J/B=3/G=(0,0,0)			i += 1		while (i<nLegends)	endif	i = 0	do		currWave = StringFromList(i,TraceList)		print "\tWorking on:",currWave		WAVE	w = $currWave		if ((i>nCols-1) %| (allBlack))			ModifyGraph RGB($currWave)=(0,0,0)		else			ModifyGraph RGB($currWave)=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		endif		ModifyGraph lsize($currWave)=1		i += 1	while (i<nWaves)		ModifyGraph opaque=1	ModifyGraph axRGB=(0,0,0)	ModifyGraph tlblRGB=(0,0,0)	ModifyGraph alblRGB=(0,0,0)	Print "--- Done ---"End//////////////////////////////////////////////////////////////////////////////////// Put cursors A and B on trace in graph, then execute this procedure to align all traces//// vertically, with the baseline specified by the cursors.Function AlignBaselineAtZero()	Variable	AutoBaseline = 0	String		AxisStr = "left"	Variable Keys = GetKeyState(0)	if (Keys & 4)		Print "You pressed the Shift key -- using auto baseline region."		AutoBaseline = 1	endif	if (Keys & 1)		Print "You pressed the Command key -- using working on the right axis instead of the left axis."		AxisStr = "right"	endif	JT_AlignBaseline(1,AutoBaseline,AxisStr)	EndFunction AlignBaselineAtMean()	Variable	AutoBaseline = 0	String		AxisStr = "left"	Variable Keys = GetKeyState(0)	if (Keys & 4)		Print "You pressed the Shift key -- using auto baseline region."		AutoBaseline = 1	endif	if (Keys & 1)		Print "You pressed the Command key -- using working on the right axis instead of the left axis."		AxisStr = "right"	endif	JT_AlignBaseline(2,AutoBaseline,AxisStr)	EndFunction JT_AlignBaseline(mode,AutoBaseline,AxisStr)	Variable	mode	Variable	AutoBaseline	String		AxisStr	String		ListOfWaves = TraceNameList("",";",1)	Variable	nItems = ItemsInList(ListOfWaves)	Print "Found ",nItems," waves in top graph."	String		CurrWave		Variable	i	Variable	x1				// This is how to think about it: x1 & x2 refers to the read-out on the x-axis, not to the position	Variable	x2				// of the cursor on an individual trace. So we need to remap the cursor position to the x axis.	Variable	xOffs	if (AutoBaseline)		GetAxis/Q bottom		x1 = V_min		x2 = (V_max-V_min)*0.05+V_min		CurrWave = StringFromList(0,ListOfWaves)		xOffs = ReadXOffset(CurrWave)		Cursor A,$(CurrWave),x1-xOffs		Cursor B,$(CurrWave),x2-xOffs	else		x1 = xcsr(A)		x1 += ReadXOffset(StringByKey("TNAME",CsrInfo(A)))		x2 = xcsr(B)		x2 += ReadXOffset(StringByKey("TNAME",CsrInfo(B)))	endif	Variable	theMean		if (x1>x2)		Variable	temp = x1		x1 = x2		x2 = temp	endif		print "The cursor positions are ("+num2str(x1)+","+num2str(x2)+")"		Variable	MeanOfMeans = 0	Variable	nItemsAveraged = 0		if (mode==2)		i = 0		do			CurrWave = StringFromList(i,ListOfWaves)			if (StringMatch(WhichYAxis(currWave),AxisStr))				xOffs = ReadXOffset(CurrWave)				WAVE	w = $CurrWave				print  nameofwave(w),currWave//				WaveStats/Q/R=(x1-xOffs,x2-xOffs) $CurrWave//				MeanOfMeans += V_avg				MeanOfMeans += Mean(w,x1-xOffs,x2-xOffs)				nItemsAveraged += 1			endif			i += 1		while (i<nItems)		MeanOfMeans /= nItemsAveraged			endif	i = 0	do		CurrWave = StringFromList(i,ListOfWaves)		if (StringMatch(WhichYAxis(currWave),AxisStr))			xOffs = ReadXOffset(CurrWave)			WAVE	w = $CurrWave			theMean = Mean(w,x1-xOffs,x2-xOffs)			ModifyGraph offset($CurrWave)={xOffs,MeanOfMeans-theMean}			//print "Doing:\t"+CurrWave," -- mean was: ",theMean		endif		i += 1	while (i<nItems)End//////////////////////////////////////////////////////////////////////////////////// Take all traces in top graph and produce a mean wave. Append this mean wave to top graph.Function ProduceMeanTrace()	String		ListOfWaves = WaveList("*",";","WIN:")	String		ListOfUsedWaves = ""	Variable	nItems = ItemsInList(ListOfWaves)	Print "Found ",nItems," waves in top graph."	String		CurrWave		String	AxisStr = "left"	Variable Keys = GetKeyState(0)	if (Keys & 1)		Print "You pressed the Command key --  working on the right axis instead of the left axis."		AxisStr = "right"	endif	Variable	i,n	Variable	avgWaveOnGraph = 0	i = 0	n = 0	do		CurrWave = StringFromList(i,ListOfWaves)		if (StringMatch(WhichYAxis(currWave),AxisStr))			if (!StringMatch(CurrWave,"avgWave_"+AxisStr))				WAVE	w = $CurrWave				// print "Doing:\t"+CurrWave				ListOfUsedWaves += CurrWave+";"				if (n==0)					Duplicate/O $CurrWave,$("avgWave_"+AxisStr)					WAVE avgWave = $("avgWave_"+AxisStr)				else					avgWave[] += w[x2pnt(w,pnt2x(avgWave,p))] // avgWave += w				endif				n += 1			else				avgWaveOnGraph = 1			endif		endif		i += 1	while(i<nItems)	avgWave /= n	Note avgWave,ListOfUsedWaves	if (!(avgWaveOnGraph))		if (StringMatch(AxisStr,"left"))			AppendToGraph/L $("avgWave_"+AxisStr)		else			AppendToGraph/R $("avgWave_"+AxisStr)		endif	endif	ModifyGraph lsize($("avgWave_"+AxisStr))=3,rgb($("avgWave_"+AxisStr))=(0,0,0)End//////////////////////////////////////////////////////////////////////////////////// Save all waves in top traceFunction SaveAllWavesInTopWindow()	string		theList =  WaveList("*",";","WIN:")	Variable	n = ItemsInList(theList,";")	string	theItem		Variable	SaveAsText = 0	Variable Keys = GetKeyState(0)	if (Keys & 4)		Print "You pressed the Shift key -- saving as Igor text instead of as Igor wave."		SaveAsText = 1	endif		String		WaveListStr = ""	variable	i	NewPath/Q/O/M="Which folder?" theStuff	if (SaveAsText)		Save/T/O/B/P=theStuff theList as StringFromList(0,theList,";")+"_etc.txt"		print "Saved these:"		print theList	else		do			theItem = StringFromList(i,theList,";")			print theItem			Save/O/C/P=theStuff  $theItem as theItem+".ibw"			i += 1		while(i<n)	endifEnd//////////////////////////////////////////////////////////////////////////////////// Colorize tracesFunction CallColorizeTraces1()	ColorizeTraces("",1)EndFunction CallColorizeTraces2()	ColorizeTraces("",2)EndFunction CallColorizeTraces3()	ColorizeTraces("",3)EndFunction CallColorizeTraces4()	ColorizeTraces("",4)EndFunction CallColorizeTraces5()	ColorizeTraces("",5)EndFunction CallColorizeTraces6()	ColorizeTraces("",6)EndFunction ColorizeTraces(list,mode)	String		list	Variable	mode	String		ListOfWaves	if (StringMatch(list,""))		ListOfWaves = TraceNameList("",";",1) //WaveList("*",";","WIN:")//		ListOfWaves = SortList(ListOfWaves,";",16)	else		ListOfWaves = list	endif	Variable	nItems = ItemsInList(ListOfWaves)	//Print "Found ",nItems," waves in top graph."	String		CurrWave		if (mode==1)		Make/O		colWaveR = {59136,26880,65280,00000, 65535,00000,29952,36873}		Make/O		colWaveG = {54784,43776,29952,65535, 00000,00000,29952,14755}		Make/O		colWaveB = {01280,64512,65280,00000, 00000,00000,29952,58982}	endif	if (mode==6)		Make/O		colWaveR = {236*256,55*256,0,128*256,236*256, 131*256}		Make/O		colWaveG = {28*256,119*256,0,128*256,142*256, 158*256}		Make/O		colWaveB = {36*256,187*256,0,128*256,145*256, 187*256}	endif		Variable	nCols = numpnts(colWaveR)		Variable	i	i = 0	do		CurrWave = StringFromList(i,ListOfWaves)		WAVE	w = $CurrWave		//print "Doing:\t"+CurrWave		if (mode==1)			ModifyGraph RGB($currWave)=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		endif		if (mode==2)			ModifyGraph RGB($CurrWave)=(65535*i/(nItems-1),0,65535*(nItems-1-i)/(nItems-1))		endif		if (mode==3)			ModifyGraph RGB($CurrWave)=(65535*i/(nItems-1),65535*(nItems-1-i)/(nItems-1),0)		endif		if (mode==4)			ModifyGraph RGB($CurrWave)=(65535*(nItems-1-i)/(nItems-1),0,65535*i/(nItems-1))		endif		if (mode==5)			ModifyGraph RGB($CurrWave)=(65535*(nItems-1-i)/(nItems-1),65535*i/(nItems-1),0)		endif		if (mode==6)			ModifyGraph RGB($currWave)=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		endif		i += 1	while(i<nItems)EndFunction JT_ColorGradient(r1,g1,b1,r2,g2,b2)	Variable	r1	Variable	g1	Variable	b1	Variable	r2	Variable	g2	Variable	b2	String		ListOfWaves = TraceNameList("",";",1) //WaveList("*",";","WIN:")	Variable	nItems = ItemsInList(ListOfWaves)	Variable	kr = (r2-r1)/(nItems-1)	Variable	kg = (g2-g1)/(nItems-1)	Variable	kb = (b2-b1)/(nItems-1)	String		CurrWave	Variable	i	i = 0	do		CurrWave = StringFromList(i,ListOfWaves)		WAVE	w = $CurrWave		ModifyGraph RGB($CurrWave)=(kr*i+r1,kg*i+g1,kb*i+b1)		// print i,kr*i+r1,kg*i+g1,kb*i+b1		i += 1	while(i<nItems)	EndFunction JT_RemoveWavesFromFolders()	string		FolderList =  DataFolderDir(1)	FolderList = FolderList[8,strlen(FolderList)-1-1-1]	Variable	nFolders = ItemsInList(FolderList,",")	String		currFolder = ""		String		wList = ""	String		currWave		Variable	i,j	i = 0	do		currFolder = StringFromList(i,FolderList,",")		SetDataFolder $("root:"+currFolder+":")		wList = WaveList("*",";","")		j = 0		do			currWave = StringFromList(j,wList)			WAVE	destW = $("root:"+currWave)			killwaves/Z destW			MoveWave $(currWave),root:			print currFolder+":"+currWave,"--> root:"			j += 1		while(j<ItemsInList(wList))		i += 1	while(i<nFolders)	SetDataFolder root:EndFunction JT_ListFilesInFolder()	NewPath/O/Q/M="Choose the folder!" ThePath	PathInfo ThePath	print "File list from "+S_path	String		fList = IndexedFile(ThePath,-1,"????")	Variable	nFiles = ItemsInList(fList)	print	"\tFound ",nFiles," files."	Variable	i	String		currFile		i = 0	do		currFile = StringFromList(i,fList)		print "",currFile		i += 1	while(i<nFiles)	EndFunction JT_TopWindowTopLeft()	String topWinStr = WinList("*",";","WIN:")	JT_MoveWindowToTopLeft(StringFromList(0,topWinStr))EndFunction JT_MoveWindowToTopLeft(WhichWindow)	String		WhichWindow		Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	Variable	xPos	Variable	yPos	Variable	width	Variable	height		Variable 	Keys = GetKeyState(0)	Variable	topRight = 0	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means top right corner."		topRight = 1	endif	// If panel already exists, keep it in the same place, please	DoWindow $WhichWindow	if (V_flag)		GetWindow $WhichWindow, wsize		width = V_right-V_left		// Need to use ScSc here on windows? I don't think so, but can't test now...		height= V_bottom-V_top		if (topRight)			Variable	xSize = JT_ScreenSize(0)			Variable	ySize = JT_ScreenSize(1)		 	Print "Moving window named "+WhichWindow+" to top right corner of screen."			xPos = xSize-width/ScSc-10			// V_left/ScSc			yPos = 50						// V_top/ScSc		else		 	Print "Moving window named "+WhichWindow+" to top left corner of screen."			xPos = 10						// V_left/ScSc			yPos = 50						// V_top/ScSc		endif	 	MoveWindow/W=$(WhichWindow) xPos*ScSc,  yPos*ScSc  ,xPos*ScSc+width*ScSc  ,yPos*ScSc+height*ScSc	 else	 	Print "Cannot find window named "+WhichWindow+"."	endif	EndFunction JT_TidyCommandWin()	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	Variable	xSize = JT_ScreenSize(0)	Variable	ySize = JT_ScreenSize(1)	Variable	width = Round(0.5*xSize)	Variable	height = Round(0.2*ySize)	Variable	xPos = 0	Variable	yPos = ySize - height -10		if (JT_thisIsWindows())		xPos += 10		yPos += 10	endif 	MoveWindow/C xPos*ScSc,  yPos*ScSc ,xPos*ScSc+width*ScSc  ,yPos*ScSc+height*ScSc 	DoWindow/F/HEnd/////////////////////////////////////////////////////////////////////////// Is Igor running on Windows?Function JT_thisIsWindows()	String		platform= UpperStr(IgorInfo(2))	Variable	pos= strsearch(platform,"WINDOWS",0)	return		pos >= 0End/////////////////////////////////////////////////////////////////////////// Produce table of waves in top graphFunction JT_EditTopGraphWaves()	String topGraphStr = StringFromList(0,WinList("*",";","WIN:1"))	GetWindow $topGraphStr, wavelist	WAVE/T	W_WaveList	Variable nWaves = DimSize(W_WaveList,0)	Print "Number of waves in window "+topGraphStr+":",nWaves	DoWindow/K JT_EditTable	Edit as "Waves in \""+topGraphStr+"\""	DoWindow/C JT_EditTable	String		currEntry	Variable i = 0	do		currEntry = W_WaveList[i][1]		if (StringMatch(currEntry[0,0],":"))			AppendToTable $("root"+W_WaveList[i][1])		else			AppendToTable $("root:"+W_WaveList[i][1])		endif		i += 1	while(i<nWaves)End/////////////////////////////////////////////////////////////////////////// Convert //			20/10/2008 (2)// to//			Mon, Oct 20, 2008// starting with the number of seconds since 1904, like Igor does.// This is to avoid operating system dependent settings	Function/S JT_MakeOldDateFormat(theSecs)	Variable	theSecs	String		UniformDate = secs2date(theSecs,-1)		Variable	Day = Str2Num(UniformDate[0,1])	Variable	Month = Str2Num(UniformDate[3,4])	Variable	Year = Str2Num(UniformDate[6,9])	Variable	DayOfWeek = Str2Num(UniformDate[12])	String		MonthList = "Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec;"	String		DayList = "Sun;Mon;Tue;Wed;Thu;Fri;Sat;"		String		DayOfWeekStr = StringFromList(DayOfWeek-1,DayList)	String		MonthStr = StringFromList(Month-1,MonthList)		String		OldDateFormat = DayOfWeekStr+", "+MonthStr+" "+num2str(Day)+", "+num2str(Year)	Return		OldDateFormatEnd/////////////////////////////////////////////////////////////////////////// Convert ExtractedEPSPs file name date information to Igor secsFunction JT_EPSPDate2Secs(dateStr)	String		dateStr		Variable	theSecs		Variable	yr,mo,dt		String	MonthList = ""	MonthList += "Jan;"	MonthList += "Feb;"	MonthList += "Mar;"	MonthList += "Apr;"	MonthList += "May;"	MonthList += "Jun;"	MonthList += "Jul;"	MonthList += "Aug;"	MonthList += "Sep;"	MonthList += "Oct;"	MonthList += "Nov;"	MonthList += "Dec;"		Variable	n = ItemsInlist(MonthList)	String		currMonth	Variable	i	Variable	FoundIt = 0	i = 0	do		currMonth = StringFromList(i,MonthList)		if (strsearch(dateStr,currMonth,0)!=-1)			FoundIt = 1			mo = i+1			i = Inf		endif		i += 1	while(i<n)		dt = str2num(dateStr[13,14])	if ((dt>31) %| (dt<1))		FoundIt = 0	else		if (dt>9)			yr = str2num(dateStr[16,19])		else			yr = str2num(dateStr[15,18])		endif		if ((yr<2000) %| (yr>2050))			FoundIt = 0		endif	endif	if (FoundIt)		Return date2secs(yr,mo,dt)	else		Return -1	endifEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Make panel for automatic loading of dataFunction JT_MakeLoadWavesPanel()	Variable	ScSc = PanelResolution("")/ScreenResolution		printf "Init LoadWaves variables: "		JT_GlobalVariable("JT_nRepsToLoad",10,"",0)	JT_GlobalVariable("JT_LoadData_Step",1,"",0)	if (Exists("JT_LoadDataFromThisChannel")==0)		Make/O/N=(4) JT_LoadDataFromThisChannel = {1,1,1,1}	// Boolean: Load data from this channel or not?	else		WAVE	JT_LoadDataFromThisChannel	endif		JT_GlobalVariable("JTLoadData_Suff1Start",1,"",0)	JT_GlobalVariable("JTLoadData_Suff2Start",1,"",0)	JT_GlobalVariable("JTLoadData_Suff3Start",1,"",0)	JT_GlobalVariable("JTLoadData_Suff4Start",1,"",0)	JT_GlobalVariable("JT_WaveNamesIn1",0,"Cell_01_",1)	JT_GlobalVariable("JT_WaveNamesIn2",0,"Cell_02_",1)	JT_GlobalVariable("JT_WaveNamesIn3",0,"Cell_03_",1)	JT_GlobalVariable("JT_WaveNamesIn4",0,"Cell_04_",1)		JT_GlobalVariable("JT_LD_xStart",53,"",0)	JT_GlobalVariable("JT_LD_xSpacing",200,"",0)	JT_GlobalVariable("JT_LD_nResponses",30,"",0)	JT_GlobalVariable("JT_LD_winWidth",120,"",0)	JT_GlobalVariable("JT_LD_xPad",5,"",0)	JT_GlobalVariable("JT_LD_RespWin",5,"",0)	JT_GlobalVariable("JT_LD_latency",7,"",0)	JT_GlobalVariable("JT_LD_pulseFreq",30,"",0)	JT_GlobalVariable("JT_LD_nPulses",3,"",0)	print "\r"	Variable	WinX = 300	Variable	WinY = 45	Variable	WinWidth = 400	Variable	WinHeight = 126+22+22*6+2	DoWindow/K JT_LoadWavesPanel	NewPanel /W=(WinX*ScSc,WinY*ScSc,WinX*ScSc+WinWidth,WinY*ScSc+WinHeight) as "JT Load Waves"	DoWindow/C JT_LoadWavesPanel	SetDrawLayer UserBack	SetDrawEnv linethick= 1,fillbgc= (1,1,1),fillfgc= (26880,43776,64512)	DrawRRect 4,2,WinWidth-4,36	SetDrawEnv fsize= 18,fstyle= 1,textrgb= (65535,65535,65535)	SetDrawEnv textxjust= 1	DrawText WinWidth/2,31,"JTools Load Waves"	Variable YShift = 40	Variable SpChX = (WinWidth-16)/4	CheckBox LoadFrom1Check pos={8+SpChX*0,YShift},size={SpChX-4,19},Proc=JT_ToggleLoadFromProc,title="Channel 1",value=JT_LoadDataFromThisChannel[0],font="Arial",fSize=12	CheckBox LoadFrom2Check pos={8+SpChX*1,YShift},size={SpChX-4,19},Proc=JT_ToggleLoadFromProc,title="Channel 2",value=JT_LoadDataFromThisChannel[1],font="Arial",fSize=12	CheckBox LoadFrom3Check pos={8+SpChX*2,YShift},size={SpChX-4,19},Proc=JT_ToggleLoadFromProc,title="Channel 3",value=JT_LoadDataFromThisChannel[2],font="Arial",fSize=12	CheckBox LoadFrom4Check pos={8+SpChX*3,YShift},size={SpChX-4,19},Proc=JT_ToggleLoadFromProc,title="Channel 4",value=JT_LoadDataFromThisChannel[3],font="Arial",fSize=12	YShift += 22	SetVariable Name1SetVar,pos={8+SpChX*0,YShift},size={SpChX-4,19},title="1:",value=JT_WaveNamesIn1	SetVariable Name2SetVar,pos={8+SpChX*1,YShift},size={SpChX-4,19},title="2:",value=JT_WaveNamesIn2	SetVariable Name3SetVar,pos={8+SpChX*2,YShift},size={SpChX-4,19},title="3:",value=JT_WaveNamesIn3	SetVariable Name4SetVar,pos={8+SpChX*3,YShift},size={SpChX-4,19},title="4:",value=JT_WaveNamesIn4	YShift += 22	Variable	firstWid = WinWidth/2-8-20	Variable	otherWid = (WinWidth-firstWid-4)/3-4	SetVariable Start1SuffSetVar,pos={4,YShift},size={firstWid-4,20},title="Start loading at: "	SetVariable Start1SuffSetVar,limits={1,Inf,1},value=JTLoadData_Suff1Start	SetVariable Start2SuffSetVar,pos={4+firstWid+(otherWid+4)*0,YShift},size={otherWid,20},title=" "	SetVariable Start2SuffSetVar,limits={1,Inf,1},value=JTLoadData_Suff2Start	SetVariable Start3SuffSetVar,pos={4+firstWid+(otherWid+4)*1,YShift},size={otherWid,20},title=" "	SetVariable Start3SuffSetVar,limits={1,Inf,1},value=JTLoadData_Suff3Start	SetVariable Start4SuffSetVar,pos={4+firstWid+(otherWid+4)*2,YShift},size={otherWid,20},title=" "	SetVariable Start4SuffSetVar,limits={1,Inf,1},value=JTLoadData_Suff4Start	YShift += 22	SetVariable nWavesSetVar,pos={4,YShift},size={WinWidth/2-8,20},title="Number of waves: "	SetVariable nWavesSetVar,limits={1,Inf,1},value=JT_nRepsToLoad	SetVariable StepSetVar,pos={4+WinWidth/2,YShift},size={WinWidth/2-8,20},title="Step between waves: "	SetVariable StepSetVar,limits={1,Inf,1},value=JT_LoadData_Step	YShift += 22	Button SkipTracesButton,pos={4+WinWidth*0/3,YShift},size={WinWidth/3-8,19},proc=JT_LD_SkipTracesProc,title="Skip traces",font="Arial",fSize=11	Button GrabFromMPButton,pos={4+WinWidth*1/3,YShift},size={WinWidth/3-8,19},proc=JT_LoadDataGrabDataProc,title="Grab from MultiPatch",font="Arial",fSize=11	DoWindow MultiPatch_Switchboard	CheckBox LoadFromMPCheck pos={4+WinWidth*2/3,YShift+1},size={WinWidth/3-8,19},title="Load from MP Home",value=V_flag,font="Arial",fSize=11		// Default to Home if MP exists	YShift += 22	Variable ColorDiv=1	CheckBox plotMeanTraceCheck pos={4+WinWidth*0/3,YShift},size={WinWidth/3-8,19},title="Plot mean trace",value=1,font="Arial",fSize=11	Button LoadTheDataButton,pos={4+WinWidth*1/3,YShift},size={WinWidth/3-8,19},proc=JT_LoadDataProc,title="Load the waves",fColor=(0,65535/ColorDiv,0),font="Arial",fSize=11	Button CloseThisPanelButton,pos={4+WinWidth*2/3,YShift},size={WinWidth/3-8,19},proc=JT_LoadDataClosePanelProc,title="Close this panel",fColor=(65535/ColorDiv,0,0),font="Arial",fSize=11	YShift += 22	// Zoom in parameters		SetVariable xStartSV,pos={4,YShift},size={WinWidth/2-8,20},title="Zoom start (ms)"	SetVariable xStartSV,limits={0,Inf,1},value=JT_LD_xStart	SetVariable xSpacingSV,pos={4+WinWidth/2,YShift},size={WinWidth/2-8,20},title="Zoom spacing (ms)"	SetVariable xSpacingSV,limits={0,Inf,100},value=JT_LD_xSpacing	YShift += 22		SetVariable nRespSV,pos={4,YShift},size={WinWidth/2-8,20},title="Number of Zooms"	SetVariable nRespSV,limits={1,Inf,1},value=JT_LD_nResponses	SetVariable winWidSV,pos={4+WinWidth/2,YShift},size={WinWidth/2-8,20},title="Zoom duration (ms)"	SetVariable winWidSV,limits={10,Inf,5},value=JT_LD_winWidth	YShift += 22		SetVariable xPadSV,pos={4,YShift},size={WinWidth/2-8,20},title="Pad before (ms)"	SetVariable xPadSV,limits={1,Inf,1},value=JT_LD_xPad	SetVariable respWinSV,pos={4+WinWidth/2,YShift},size={WinWidth/2-8,20},title="Response window (ms)"	SetVariable respWinSV,limits={0,Inf,1},value=JT_LD_RespWin	YShift += 22		SetVariable latencySV,pos={4,YShift},size={WinWidth/2-8,20},title="Response latency (ms)"	SetVariable latencySV,limits={1,Inf,1},value=JT_LD_latency	SetVariable freqSV,pos={4+WinWidth/2,YShift},size={WinWidth/2-8,20},title="Response frequency (Hz)"	SetVariable freqSV,limits={5,Inf,5},value=JT_LD_pulseFreq	YShift += 22	SetVariable nPulsesSV,pos={4,YShift+2},size={WinWidth/5-4,20},title="nPulses"	SetVariable nPulsesSV,limits={1,Inf,1},value=JT_LD_nPulses	Button LoadTheDataButton2,pos={4+WinWidth*1/5,YShift},size={WinWidth/5-4,19},proc=JT_LoadDataProc,title="Load+Zoom",fColor=(0,65535/ColorDiv,0),font="Arial",fSize=11	Button ToFrontButton,pos={4+WinWidth*2/5,YShift},size={WinWidth/5-4,19},proc=JT_LoadData_toFrontProc,title="Front",font="Arial",fSize=11	Button ToBackButton,pos={4+WinWidth*3/5,YShift},size={WinWidth/5-4,19},proc=JT_LoadData_toBackProc,title="Back",font="Arial",fSize=11	Button RefreshButton,pos={4+WinWidth*4/5,YShift},size={WinWidth/5-8,19},proc=JT_LoadData_RefreshProc,title="Refresh",font="Arial",fSize=11	YShift += 22End//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Read checkboxes from JT_LoadWavesPanel and save stateFunction JT_ToggleLoadFromProc(ctrlName,checked) : CheckBoxControl	String	ctrlName	Variable	checked	WAVE		JT_LoadDataFromThisChannel	Variable	MP_AtLeastOneLoad		Variable		index = str2num(ctrlName[8,8])-1		JT_LoadDataFromThisChannel[index] = checked	MP_AtLeastOneLoad = 0	Variable	i = 0	do			if (JT_LoadDataFromThisChannel[i])			MP_AtLeastOneLoad = 1		endif		i += 1	while(i<4)	if (MP_AtLeastOneLoad==0)		JT_LoadDataFromThisChannel[index] = 1		CheckBox $("LoadFrom"+num2str(index+1)+"Check") value = 1		Print "Leave at least one channel checked!"	endifEnd/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Grab data from the MultiPatch SwitchBoardFunction JT_LD_SkipTracesProc(ctrlName) : ButtonControl	String ctrlName		JT_LD_ExistsSkipWaves()	WAVE	JT_LD_SkipTraces1,JT_LD_SkipTraces2,JT_LD_SkipTraces3,JT_LD_SkipTraces4	DoWindow/K JT_LD_SkipTracesTable	Edit/K=1/W=(290,374,729,641) JT_LD_SkipTraces1,JT_LD_SkipTraces2,JT_LD_SkipTraces3,JT_LD_SkipTraces4 as "Skip Trace Suffix Table"	DoWindow/C JT_LD_SkipTracesTable	ModifyTable format(Point)=1	ModifyTable title(JT_LD_SkipTraces1)="Channel 1"	ModifyTable title(JT_LD_SkipTraces2)="Channel 2"	ModifyTable title(JT_LD_SkipTraces3)="Channel 3"	ModifyTable title(JT_LD_SkipTraces4)="Channel 4"		AutoPositionWindow/M=1/R=JT_LoadWavesPanel JT_LD_SkipTracesTableEnd/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// If the skip-traces waves do not exist, create themFunction JT_LD_ExistsSkipWaves()	if (Exists("JT_LD_SkipTraces1")==0)		Make/O/N=(10) JT_LD_SkipTraces1,JT_LD_SkipTraces2,JT_LD_SkipTraces3,JT_LD_SkipTraces4		JT_LD_SkipTraces1 = 0		JT_LD_SkipTraces2 = 0		JT_LD_SkipTraces3 = 0		JT_LD_SkipTraces4 = 0	endifEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Grab data from the MultiPatch SwitchBoardFunction JT_LoadDataGrabDataProc(ctrlName) : ButtonControl	String ctrlName		if (exists("root:MP:IO_Data:StartAt1")==0)		Print "Cannot grab data from MultiPatch because MultiPatch has mot been started up."		Abort "Cannot grab data from MultiPatch because MultiPatch has mot been started up."	endif	Print "Grabbing wave names and suffix starting points from MultiPatch Switchboard."	// Parameters from the MultiPatch_SwitchBoard	NVAR		StartAt1 = 				root:MP:IO_Data:StartAt1	NVAR		StartAt2 = 				root:MP:IO_Data:StartAt2	NVAR		StartAt3 = 				root:MP:IO_Data:StartAt3	NVAR		StartAt4 = 				root:MP:IO_Data:StartAt4		SVAR		WaveNamesIn1 = 			root:MP:IO_Data:WaveNamesIn1	SVAR		WaveNamesIn2 = 			root:MP:IO_Data:WaveNamesIn2	SVAR		WaveNamesIn3 = 			root:MP:IO_Data:WaveNamesIn3	SVAR		WaveNamesIn4 = 			root:MP:IO_Data:WaveNamesIn4	// Parameters from the JT Load Waves panel	NVAR		nRepsToLoad = JT_nRepsToLoad	NVAR		LoadData_Step = JT_LoadData_Step	NVAR		LoadData_Suff1Start = JTLoadData_Suff1Start	NVAR		LoadData_Suff2Start = JTLoadData_Suff2Start	NVAR		LoadData_Suff3Start = JTLoadData_Suff3Start	NVAR		LoadData_Suff4Start = JTLoadData_Suff4Start		SVAR		JT_WaveNamesIn1	SVAR		JT_WaveNamesIn2	SVAR		JT_WaveNamesIn3	SVAR		JT_WaveNamesIn4		JT_WaveNamesIn1 = WaveNamesIn1	JT_WaveNamesIn2 = WaveNamesIn2	JT_WaveNamesIn3 = WaveNamesIn3	JT_WaveNamesIn4 = WaveNamesIn4		LoadData_Suff1Start = StartAt1-nRepsToLoad*LoadData_Step	if (LoadData_Suff1Start<1)		LoadData_Suff1Start = 1	endif		LoadData_Suff2Start = StartAt2-nRepsToLoad*LoadData_Step	if (LoadData_Suff2Start<1)		LoadData_Suff2Start = 1	endif		LoadData_Suff3Start = StartAt3-nRepsToLoad*LoadData_Step	if (LoadData_Suff3Start<1)		LoadData_Suff3Start = 1	endif		LoadData_Suff4Start = StartAt4-nRepsToLoad*LoadData_Step	if (LoadData_Suff4Start<1)		LoadData_Suff4Start = 1	endif	End//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Is this a trace to be skipped or used?Function JT_LD_UseThisTrace(suffixNumber,skipWave)	Variable		suffixNumber	WAVE			skipWave		Variable		notInSkipList = 1	Variable	n = numpnts(skipWave)	Variable	i	i = 0	do		if (suffixNumber == skipWave[i])			i = Inf			notInSkipList = 0		endif		i += 1	while(i<n)		Return notInSkipListEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Load the data!!!Function JT_LoadDataProc(ctrlName) : ButtonControl	String ctrlName	Variable 	Keys = GetKeyState(0)	Variable		ReusePath = 0	Variable		LoadAverages = 0	Variable 	zoomIn = stringMatch(ctrlName,"LoadTheDataButton2")		Variable		CMap_remoteControl = 0	if (stringMatch(ctrlName,"CMap_remoteControl"))		CMap_remoteControl = 1	endif	if (CMap_remoteControl)		// CMap remote call overrides		zoomIn = 1		ReusePath = 1		LoadAverages = 0	else		if (Keys & 2^2)			Print "\tYou pressed the Shift key. This means you wish to load from same path again."			ReusePath = 1		endif		if (zoomIn==0)			// Zoom-in feature overrides the load-averages feature			if (Keys & 2^0)				Print "\tYou pressed the Command key. This means loading the average waves instead."				LoadAverages = 1			endif		endif	endif	// Names	SVAR		JT_WaveNamesIn1	SVAR		JT_WaveNamesIn2	SVAR		JT_WaveNamesIn3	SVAR		JT_WaveNamesIn4	// Parameters from the LoadDataPanel	NVAR		JT_nRepsToLoad	NVAR		JTLoadData_Suff1Start	NVAR		JTLoadData_Suff2Start	NVAR		JTLoadData_Suff3Start	NVAR		JTLoadData_Suff4Start	NVAR		JT_LoadData_Step	WAVE		JT_LoadDataFromThisChannel		// Parameters for zooming in	NVAR		JT_LD_xStart						// Start of first response (ms)	NVAR		JT_LD_xSpacing					// Separation of responses (ms)	NVAR		JT_LD_nResponses				// Number of responses to display	NVAR		JT_LD_winWidth					// Window width (ms)	NVAR		JT_LD_xPad						// Padding before response (ms)	NVAR		JT_LD_RespWin					// Response window (ms)	NVAR		JT_LD_latency					// Latency to peak (ms)	NVAR		JT_LD_pulseFreq					// Pulse frequency (Hz)	NVAR		JT_LD_nPulses					// Number of pulse	JT_LD_ExistsSkipWaves()					// If the waves denoting which waves to skip do not exist, create them	WAVE	JT_LD_SkipTraces1,JT_LD_SkipTraces2,JT_LD_SkipTraces3,JT_LD_SkipTraces4		Variable	nDigs = 4							// Number of digits in the suffix number appended at the end of the waves	Variable	plotMeanTrace = 0	Variable	LoadFromMP = 0	if (CMap_remoteControl)		plotMeanTrace = 1						// Mean trace should be created, not loaded		LoadFromMP = 0	else		ControlInfo/W=JT_LoadWavesPanel plotMeanTraceCheck		plotMeanTrace = V_Value		if (LoadAverages)			plotMeanTrace = 0					// If user wants to load the averages, then averageWave should not be created		endif			ControlInfo/W=JT_LoadWavesPanel LoadFromMPCheck		LoadFromMP = V_Value		if (LoadFromMP)			PathInfo Home			if (V_flag==0)				print "The MultiPatch Home path does not exist, so waves cannot be loaded from that path."				LoadFromMP = 0			endif		endif	endif	Variable		i,j,k	String		Name	Variable		nChannelsSelected = 0		Print "--- Loading waves ---"	Print "\tTime: "+Time()	if (LoadFromMP)		PathInfo Home		NewPath/O/Q/Z JT_path,S_path		if (V_flag)			Abort "Failed to use the Home path."		endif	else		PathInfo JT_path		if ((V_Flag==0) %| (ReusePath==0))			if (V_Flag)				print "Targetting most recently used path."				PathInfo/S JT_path			endif			NewPath/M="Select path to load from!"/O/Q JT_path			if (V_flag)				Abort "Cancelled."			endif		else			NewPath/O/Q/Z JT_path,S_path			if (V_flag)				Abort "Failed to reuse previous path."			endif		endif	endif	PathInfo JT_path	Print "Loading the waves from: "+S_path	i = 0	do		if (JT_LoadDataFromThisChannel[i])			nChannelsSelected += 1			Print "Loading from channel "+num2str(i+1)+"."			printf "\tLoading waves: "			SVAR	baseName = $("JT_WaveNamesIn"+num2str(i+1))			NVAR	suffix = $("JTLoadData_Suff"+num2str(i+1)+"Start")			if (LoadAverages)				Name = baseName+"average"				Print Name				LoadWave/H/Q/P=JT_path/O Name				if (V_flag==0)					Abort "Cannot load \""+Name+"\"."				endif			else				WAVE wSkipTraces = $("JT_LD_SkipTraces"+num2str(i+1))				j = 0				do					Name = baseName+JT_num2digstr(nDigs,j*JT_LoadData_Step+suffix)					Printf Name					if (JT_LD_UseThisTrace(j*JT_LoadData_Step+suffix,wSkipTraces))						LoadWave/H/Q/P=JT_path/O Name						if (V_flag==0)							Printf " (fail)\r"							Abort "Cannot load \""+Name+"\"."						endif					else						Printf " (skipped)"					endif					if (j+1<JT_nRepsToLoad)						Printf ", "					else						print "\r"					endif					j += 1				while(j<JT_nRepsToLoad)			endif		endif		i += 1	while(i<4)		// Make the graphs	Variable	ScSc = PanelResolution("")/ScreenResolution		Variable	WinX = 300+290	Variable	WinY = 45+50	Variable	WinWidth = 360	Variable	Skip = 24	Variable	TotHeight = 120*4+Skip*4		Variable	WinHeight = TotHeight/nChannelsSelected-Skip			// Scale graph height according to number of channels selected	Variable	MaxHeight = 250	if (WinHeight>MaxHeight)		WinHeight = MaxHeight	endif	Variable	currWinY = WinY	JT_LoadData_CloseProc("")	if (LoadAverages)		DoWindow/K JT_LoadDataGr		Display /W=(WinX*ScSc,WinY*ScSc,WinX*ScSc+WinWidth,WinY*ScSc+WinHeight) as "Loaded data"		DoWindow/C JT_LoadDataGr		Button ClosePlotsButton,pos={0,0},size={18,18},proc=JT_LoadData_CloseProc,title="X",font="Arial",fsize=12,fstyle=1	endif	Make/O		colWaveR = {59136,26880,65280,00000, 65535,00000,29952,36873}	Make/O		colWaveG = {54784,43776,29952,65535, 00000,00000,29952,14755}	Make/O		colWaveB = {01280,64512,65280,00000, 00000,00000,29952,58982}		String		LegendStr = ""	Variable		theFirst = 1		Variable		nRepsAveraged = 0	i = 0	do		if (JT_LoadDataFromThisChannel[i])			SVAR	baseName = $("JT_WaveNamesIn"+num2str(i+1))			NVAR	suffix = $("JTLoadData_Suff"+num2str(i+1)+"Start")			if (LoadAverages)				Name = baseName+"average"				LegendStr += "\s("+Name+") "+baseName[0,StrLen(baseName)-1-1]+"\r"				if (Exists(Name)==1)					AppendToGraph/W=JT_LoadDataGr $Name					ModifyGraph/W=JT_LoadDataGr RGB($Name)=(colWaveR[i],colWaveG[i],colWaveB[i])				endif			else				theFirst = 1				Print "Making graph for channel "+num2str(i+1)+"."				DoWindow/K $("JT_LoadDataGr_"+num2str(i+1))				Display /W=(WinX,currWinY,WinX+WinWidth,currWinY+WinHeight) as "Channel #"+num2str(i+1)				DoWindow/C $("JT_LoadDataGr_"+num2str(i+1))				Button ClosePlotsButton,pos={0,0},size={18,18},proc=JT_LoadData_CloseProc,title="X",font="Arial",fsize=12,fstyle=1				Button JT_WinResizeButton,pos={1,16},size={16,19},proc=JT_WinResizeProc,title="R",fSize=12,font="Arial",fstyle=1				WAVE wSkipTraces = $("JT_LD_SkipTraces"+num2str(i+1))				nRepsAveraged = 0				j = 0				do					Name = baseName+JT_num2digstr(nDigs,j*JT_LoadData_Step+suffix)					if (j==0)						LegendStr += "\s("+Name+") "+baseName[0,StrLen(baseName)-1-1]+"\r"					endif					if (JT_LD_UseThisTrace(j*JT_LoadData_Step+suffix,wSkipTraces))						if (Exists(Name)==1)							AppendToGraph/W=$("JT_LoadDataGr_"+num2str(i+1)) $Name							ModifyGraph/W=$("JT_LoadDataGr_"+num2str(i+1)) RGB($Name)=(colWaveR[i],colWaveG[i],colWaveB[i])							if (theFirst)								Duplicate/O $Name,$("avgWave_"+num2str(i+1))								WAVE	avgWave = $("avgWave_"+num2str(i+1))								theFirst = 0								nRepsAveraged = 1							else								WAVE	sourceWave = $Name								avgWave += sourceWave								nRepsAveraged += 1							endif						endif					endif					j += 1				while(j<JT_nRepsToLoad)				avgWave /= nRepsAveraged				if (plotMeanTrace)					AppendToGraph/W=$("JT_LoadDataGr_"+num2str(i+1)) $("avgWave_"+num2str(i+1))					ModifyGraph/W=$("JT_LoadDataGr_"+num2str(i+1)) rgb($("avgWave_"+num2str(i+1)))=(0,0,0)				endif				currWinY += WinHeight+Skip			endif		endif		i += 1	while(i<4)		LegendStr = LegendStr[0,StrLen(LegendStr)-1-1]	Legend LegendStr		ModifyGraph prescaleExp(left)=3	Variable	buttonFontSize = 8	Variable	buttonWidth = 18		Variable	JT_LD_dirWinSize = 1			// Size of direct activation measurement windows (ms)	if (zoomIn)		Variable	respAmp = 0		Variable	pVal		Variable	connectedFlag		Variable	directFlag		Variable	trashFlag = 0				// not used here, but has to be set and passed to other functions		Variable	buttonMode		String/G	JT_LD_GraphList = ""		Variable yCenter		Variable yRange		Variable yZoomOut		Variable yNewRange		Variable yMax		Variable	yMin		i = 0		do			if (JT_LoadDataFromThisChannel[i])				pauseUpdate				Make/O/N=(JT_LD_nResponses) $("JT_LD_isTrashWave"+num2str(i+1))		// Boolean: is trash, to be discarded as a non-tested candidate input				WAVE JT_LD_isTrashWave = $("JT_LD_isTrashWave"+num2str(i+1))				JT_LD_isTrashWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_directDepWave"+num2str(i+1))		// Amount of direct depolarization				WAVE JT_LD_directDepWave = $("JT_LD_directDepWave"+num2str(i+1))				JT_LD_directDepWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_isDirectWave"+num2str(i+1))		// Boolean: is statistically likely to be direct depolarization				WAVE JT_LD_isDirectWave = $("JT_LD_isDirectWave"+num2str(i+1))				JT_LD_isDirectWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseWave"+num2str(i+1))		// Boolean: is statistically likely to be a response (possibly a direct one though)				WAVE JT_LD_responseWave = $("JT_LD_responseWave"+num2str(i+1))				JT_LD_responseWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseAmp1Wave"+num2str(i+1))	// Amplitude of pulse 1				WAVE JT_LD_responseAmp1Wave = $("JT_LD_responseAmp1Wave"+num2str(i+1))				JT_LD_responseAmp1Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseAmp2Wave"+num2str(i+1))	// Amplitude of pulse 2				WAVE JT_LD_responseAmp2Wave = $("JT_LD_responseAmp2Wave"+num2str(i+1))				JT_LD_responseAmp2Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseAmp3Wave"+num2str(i+1))	// Amplitude of pulse 3				WAVE JT_LD_responseAmp3Wave = $("JT_LD_responseAmp3Wave"+num2str(i+1))				JT_LD_responseAmp3Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseCV1Wave"+num2str(i+1))	// CV of pulse 1				WAVE JT_LD_responseCV1Wave = $("JT_LD_responseCV1Wave"+num2str(i+1))				JT_LD_responseCV1Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseCV2Wave"+num2str(i+1))	// CV of pulse 2				WAVE JT_LD_responseCV2Wave = $("JT_LD_responseCV2Wave"+num2str(i+1))				JT_LD_responseCV2Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseCV3Wave"+num2str(i+1))	// CV of pulse 3				WAVE JT_LD_responseCV3Wave = $("JT_LD_responseCV3Wave"+num2str(i+1))				JT_LD_responseCV3Wave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responsePPRWave"+num2str(i+1))	// Paired-pulse ratio				WAVE JT_LD_responsePPRWave = $("JT_LD_responsePPRWave"+num2str(i+1))				JT_LD_responsePPRWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_responseTPRWave"+num2str(i+1))	// Triple-pulse ratio				WAVE JT_LD_responseTPRWave = $("JT_LD_responseTPRWave"+num2str(i+1))				JT_LD_responseTPRWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_maxDepolWave"+num2str(i+1))		// Amplitude of maximum depolarization				WAVE JT_LD_maxDepolWave = $("JT_LD_maxDepolWave"+num2str(i+1))				JT_LD_maxDepolWave = 0				Make/O/N=(JT_LD_nResponses) $("JT_LD_maxDepolLocWave"+num2str(i+1))	// Latency (ms) of maximum depolarization				WAVE JT_LD_maxDepolLocWave = $("JT_LD_maxDepolLocWave"+num2str(i+1))				JT_LD_maxDepolLocWave = 0				Print "Zooming in for channel "+num2str(i+1)+"."				k = 0			// k counts JT_LD_nResponses				do					DoWindow/K $("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))					Display as "Ch"+num2str(i+1)+", R"+num2str(k)					DoWindow/C $("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))					killStrings/Z $("JTpos_"+"JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))			// Get rid of any previously stored window positions (see JT_WinResizeProc)					JT_LD_GraphList += "JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)+";"					ControlBar/L buttonWidth+2					Button ClosePlotsButton,pos={0,0},size={buttonWidth,17},proc=JT_LoadData_CloseProc,title="X",font="Arial",fsize=buttonFontSize,fstyle=1,help={"Close all windows."}					SVAR	baseName = $("JT_WaveNamesIn"+num2str(i+1))					NVAR	suffix = $("JTLoadData_Suff"+num2str(i+1)+"Start")					Make/O/N=(0) workWave,workWave2,workWave3,workWaveD					WAVE wSkipTraces = $("JT_LD_SkipTraces"+num2str(i+1))					j = 0		// j counts JT_nRepsToLoad					do						Name = baseName+JT_num2digstr(nDigs,j*JT_LoadData_Step+suffix)						if (JT_LD_UseThisTrace(j*JT_LoadData_Step+suffix,wSkipTraces))							if (Exists(Name)==1)								AppendToGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) $Name								ModifyGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) rgb($Name)=(colWaveR[i],colWaveG[i],colWaveB[i]),lsize($Name)=0.1								WAVE	w = $Name								// Calculate direct activation amplitude								workWaveD[numpnts(workWaveD)] = {Mean(w,(JT_LD_xStart+JT_LD_xSpacing*k)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_dirWinSize)*1e-3) - Mean(w,(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin+JT_LD_dirWinSize)*1e-3)}								// Calculate first response amplitude								respAmp = Mean(w,(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency+JT_LD_RespWin)*1e-3) - Mean(w,(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k)*1e-3)								workWave[numpnts(workWave)] = {respAmp}								// Calculate second response amplitude if possible, for the purposes of paired-pulse calculations								if (JT_LD_nPulses>1)									respAmp = Mean(w,1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency)*1e-3,1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency+JT_LD_RespWin)*1e-3) - Mean(w,1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin)*1e-3,1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k)*1e-3)									workWave2[numpnts(workWave2)] = {respAmp}								endif								if (JT_LD_nPulses>2)									respAmp = Mean(w,2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency)*1e-3,2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_latency+JT_LD_RespWin)*1e-3) - Mean(w,2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin)*1e-3,2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*k)*1e-3)									workWave3[numpnts(workWave2)] = {respAmp}								endif							endif						endif						j += 1					while(j<JT_nRepsToLoad)					// Collect stats on possible direct activation					WaveStats/Q workWaveD					JT_LD_directDepWave[k] = V_avg					// Figure out if, statistically speaking, there is direct activation here					pVal = JT_oneSampleTTest(workWaveD,0)					directFlag = (pVal < 0.05) %& (JT_LD_directDepWave[k] > 0)					JT_LD_isDirectWave[k] = directFlag					// Collect stats on responses					WaveStats/Q workWave					JT_LD_responseAmp1Wave[k] = V_avg					JT_LD_responseCV1Wave[k] = V_Sdev/V_avg					if (JT_LD_nPulses>1)		// If there is a second pulse						WaveStats/Q workWave2						JT_LD_responseAmp2Wave[k] = V_avg						JT_LD_responseCV2Wave[k] = V_Sdev/V_avg						JT_LD_responsePPRWave[k] = JT_LD_responseAmp2Wave[k]/JT_LD_responseAmp1Wave[k]					endif					if (JT_LD_nPulses>2)		// If there is a third pulse						WaveStats/Q workWave3						JT_LD_responseAmp3Wave[k] = V_avg						JT_LD_responseCV3Wave[k] = V_Sdev/V_avg						JT_LD_responseTPRWave[k] = (JT_LD_responseAmp2Wave[k]+JT_LD_responseAmp3Wave[k])/(2*JT_LD_responseAmp1Wave[k])		// TPR is the mean of E2 and E3 divided by E1					endif					// Figure out if, statistically speaking, there is a response here					pVal = JT_oneSampleTTest(workWave,0)					connectedFlag = pVal < 0.05					JT_LD_responseWave[k] = connectedFlag					Button $("hasResponseButton"+num2str(i+1)+JT_num2digstr(4,k)),pos={1,16},size={buttonWidth,17},title="0",proc=JT_LD_ButtonProc,fSize=buttonFontSize,font="Arial",fstyle=1,help={"0 - not connected\r1 - connected\rd - direct (not connected)\rD - direct & connected\rT - Trash: omit from stats"}					buttonMode = connectedFlag*2^0 + directFlag*2^1		// Cannot be flagged as trash at this point, CMap_doPushBackConnectivity will take care of that					JT_LD_setButton("hasResponseButton"+num2str(i+1)+JT_num2digstr(4,k),buttonMode)//					CheckBox $("hasResponseCheck"+num2str(i+1)+JT_num2digstr(4,k)) pos={2,15},size={buttonWidth,19},title=" ",proc=JT_LD_RespWinCheckProc,value=connectFlag,font="Arial",fSize=12					Button JT_WinResizeButton,pos={1,32},size={buttonWidth,17},proc=JT_WinResizeProc,title="R",fSize=buttonFontSize,font="Arial",fstyle=1,help={"Resize: Make window big if it is small.\rMake window small if it is big."}					Button PlotsToBackButton,pos={1,48},size={buttonWidth,17},proc=JT_LoadData_toBackProc,title="B",fSize=buttonFontSize,font="Arial",fstyle=1,help={"Move all plots to back."}					Button PlotsToFrontButton,pos={1,64},size={buttonWidth,17},proc=JT_LoadData_toFrontProc,title="F",fSize=buttonFontSize,font="Arial",fstyle=1,help={"Move all plots to front."}					Button $("StatsButton"+num2str(i+1)+"_"+num2str(k)),pos={1,80},size={buttonWidth,17},proc=JT_LoadData_StatsProc,title="S",fSize=buttonFontSize,font="Arial",fstyle=1,help={"List stats table.\rWill highlight the selected response,\rif it is a response,\rotherwise just shows the stats table."}					Button AutoYbutton,pos={1,96},size={buttonWidth,17},proc=JT_LoadData_AutoYproc,title="A",fSize=buttonFontSize,font="Arial",fstyle=1,help={"Auto-scale y-axis of all plots."}					if (plotMeanTrace)						AppendToGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) $("avgWave_"+num2str(i+1))						ModifyGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) rgb($("avgWave_"+num2str(i+1)))=(0,0,0),lsize($("avgWave_"+num2str(i+1)))=2					endif					ModifyGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) margin(top) = 2, margin(right) = 10, margin(left) = 13, margin(bottom) = 13, btLen = 2	// btLen sorts Igor bug with internal ticks scaling label pos as if they were outside					ModifyGraph/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) font="Arial",fSize=8, tick=2,  standoff=0, nticks(left)=3, nticks(bottom)=3, tkLblRot(left)=90					Label/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left "\\u#2"					Label/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) bottom "\\u#2"					// Calculate y-axis range					if (plotMeanTrace)						WAVE	meanTrace = $("avgWave_"+num2str(i+1))						WaveStats/Q/R=((JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_xPad)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_winWidth-JT_LD_xPad)*1e-3) meanTrace						yCenter = (V_min+V_max)/2						yRange = V_max-V_min						yZoomOut = 1.2						yNewRange = yRange*yZoomOut						yMax = yCenter+yNewRange/2						yMin = yCenter-yNewRange/2						SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left,yMin,yMax					else						SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))/A=2 left					endif					SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) Bottom,(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_xPad)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_winWidth-JT_LD_xPad)*1e-3					JT_AlignBaselineLikeMP(2,"left",(JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_RespWin)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k)*1e-3)					Cursor/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))/K A					Cursor/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))/K B					JT_LD_DrawBars(k,connectedFlag,directFlag,trashFlag)												// Label clearly the windows with the responses					JT_LD_DrawBarsZoomedOut(k,"JT_LoadDataGr_"+num2str(i+1))			// Do the same thing with the zoomed-out graph					// Re-extract the Amp1 and Amp2 response amplitudes from the average traces					if (plotMeanTrace)						WAVE wMean = $("avgWave_"+num2str(i+1))						JT_LD_FindRespAmps(k,wMean)						NVAR		JT_LD_Amp1								// These are calculated in JT_LD_FindRespAmps						NVAR		JT_LD_MaxDepol						NVAR		JT_LD_MaxDepolLoc						JT_LD_responseAmp1Wave[k] = JT_LD_Amp1		// At this stage, the CV is crudely calculated from fixed windows, but the amplitudes are calculated in a relatively intelligent manner						JT_LD_maxDepolWave[k] = JT_LD_MaxDepol						JT_LD_maxDepolLocWave[k] = JT_LD_MaxDepolLoc						if (JT_LD_nPulses>1)							NVAR		JT_LD_Amp2							JT_LD_responseAmp2Wave[k] = JT_LD_Amp2							JT_LD_responsePPRWave[k] = JT_LD_Amp2/JT_LD_Amp1								// JT_LD_responseAmp2Wave[k]/JT_LD_responseAmp1Wave[k]						endif						if (JT_LD_nPulses>2)							NVAR		JT_LD_Amp3							JT_LD_responseAmp3Wave[k] = JT_LD_Amp3							JT_LD_responseTPRWave[k] = (JT_LD_Amp2+JT_LD_Amp3)/(2*JT_LD_Amp1)		// (JT_LD_responseAmp2Wave[k]+JT_LD_responseAmp3Wave[k])/(2*JT_LD_responseAmp1Wave[k])						endif					endif					k += 1				while(k<JT_LD_nResponses)				resumeUpdate			endif			i += 1		while(i<4)		Variable JT_LD_nGraphs = JT_LD_nResponses*sum(JT_LoadDataFromThisChannel)		Variable	JT_LD_nGraphCols = 5		Variable	JT_LD_nGraphRows = JT_LD_nGraphCols-1		if (JT_LD_nGraphs>JT_LD_nGraphRows*JT_LD_nGraphCols)			do				if (JT_LD_nGraphRows<JT_LD_nGraphCols)					JT_LD_nGraphRows += 1				else					JT_LD_nGraphCols += 1				endif			while(JT_LD_nGraphs>JT_LD_nGraphRows*JT_LD_nGraphCols)		endif		JT_ArrangeGraphs2(JT_LD_GraphList,JT_LD_nGraphRows,JT_LD_nGraphCols)	endif	Print "--- Done ---"End//////////////////////////////////////////////////////////////////////////////////// Convert a numeric variable to a string of bit values//// theNum must be positive; cannot handle 2's complementFunction/S JT_num2bitStr(theNum,nDigits)	Variable	theNum	Variable	nDigits	String		theStr = ""	Variable	currBit		theNum = floor(theNum)		if (theNum>-1)		// Cannot handle negatives; does not do 2's complement		do			currBit = mod(theNum,2)			if (currBit)				theStr += "1"			else				theStr += "0"			endif			theNum = floor(theNum/2)		while(strLen(theStr)<nDigits)	endif		theStr = JT_reverseStr(theStr)		Return theStrEnd//////////////////////////////////////////////////////////////////////////////////// Take a string and reverses its order, so ABC -> CBAFunction/S JT_reverseStr(theStr)	String	theStr		String		outStr = ""	Variable	i	i = StrLen(theStr)-1	do		outStr += theStr[i]		i -= 1	while(i>-1)		Return outStrEnd//////////////////////////////////////////////////////////////////////////////////// Takes a string of bit values and converts it to a numeric value//// The functional inverse of JT_num2bitStrFunction JT_bitStr2num(theStr)	String		theStr	Variable	theNum = 0	Variable	i,j	i = StrLen(theStr)-1	j = 0	do		if (StringMatch(theStr[i],"1"))			// Assuming a well-behaved string of 1's and 0's			theNum += 2^j		endif		j += 1		i -= 1	while(i>-1)		Return	theNumEnd//////////////////////////////////////////////////////////////////////////////////// Takes a string of bit values and tests the bit in position pos//// Returns a numeric boolean 1 or 0Function JT_testBitStr(theStr,pos)	String		theStr		// bit string	Variable	pos			// starts counting from zero, backwards		Variable	result		// 1 if set, 0 if not, -1 if testing outside the bit string		if ( (pos>strLen(theStr)-1) %| (pos<0) )		result = -1	else		if (stringMatch(theStr[strLen(theStr)-1-pos],"1"))		// Assuming a well-behaved string of 1's and 0's			result = 1		else			result = 0		endif	endif		return	resultEnd//////////////////////////////////////////////////////////////////////////////////// Takes a string of bit values and sets the bit in position pos to 1 or 0Function/S JT_setBitStr(theStr,pos,value)	String		theStr		// bit string	Variable	pos			// starts counting from zero, backwards	Variable	value		// Boolean: 1 or 0	if ((pos<0) %| (pos>strLen(theStr)-1))		// pass through	else		if (value)			theStr[strLen(theStr)-1-pos,strLen(theStr)-1-pos] = "1"		else			theStr[strLen(theStr)-1-pos,strLen(theStr)-1-pos] = "0"		endif	endif			Return		theStr	End//////////////////////////////////////////////////////////////////////////////////// Action procedure for response buttonFunction JT_LD_ButtonProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			Variable buttonMode = JT_LD_getButton(ba.ctrlName)			Variable toggle = 0			Variable Keys = GetKeyState(0)			// If user holds shift, then toggle connection on off			if (Keys & 2^2)				toggle = 1			endif			if (toggle)									// Toggle connection on/off, assuming that the direct activation was correctly algorithmically detected				switch(buttonMode)					case 0:						buttonMode = 1						break					case 1:						buttonMode = 0						break					case 2:						buttonMode = 3						break					case 3:						buttonMode = 2						break				endswitch			else				buttonMode += 1				if (buttonMode>4)					buttonMode = 0				endif			endif			JT_LD_setButton(ba.ctrlName,buttonMode)			JT_LD_updateZoomFromButton(ba.ctrlName,buttonMode)			break		case -1: // control being killed			break	endswitch	return 0End//////////////////////////////////////////////////////////////////////////////////// Update Zoom graphs from mode buttonFunction JT_LD_updateZoomFromButton(ctrlName,buttonMode)	String		ctrlName	Variable		buttonMode	Variable		winNumber = str2num(ctrlName[strLen(ctrlName)-4,strLen(ctrlName)-1])	Variable		channel = str2num(ctrlName[strLen(ctrlName)-5,strLen(ctrlName)-5])		WAVE/Z		JT_LD_responseWave = $("JT_LD_responseWave"+num2str(channel))	WAVE/Z		JT_LD_isDirectWave = $("JT_LD_isDirectWave"+num2str(channel))	WAVE/Z		JT_LD_isTrashWave = $("JT_LD_isTrashWave"+num2str(channel))	Variable		connectedFlag = mod(floor(buttonMode/2^0),2)	// Bit 0	Variable		directFlag = mod(floor(buttonMode/2^1),2)		// Bit 1	Variable		trashFlag = mod(floor(buttonMode/2^2),2)		// Bit 2	JT_LD_responseWave[winNumber] = connectedFlag	JT_LD_isDirectWave[winNumber] = directFlag	JT_LD_isTrashWave[winNumber] = trashFlag	JT_LD_DrawBars(winNumber,connectedFlag,directFlag,trashFlag)			// Label clearly the windows with the responsesEnd//////////////////////////////////////////////////////////////////////////////////// Read out response button mode, which is numbered zero through four as://// 	0 - not connected//// 	1 - connected//// 	d - direct (not connected)//// 	D - direct & connected//// 	T - Trash: omit from statsFunction JT_LD_getButton(ctrlName)	String	ctrlName		Variable		winNumber = str2num(ctrlName[strLen(ctrlName)-4,strLen(ctrlName)-1])	Variable		channel = str2num(ctrlName[strLen(ctrlName)-5,strLen(ctrlName)-5])	controlinfo/W=$("JT_LD_ZoomGr_"+num2str(channel)+"_"+num2str(winNumber)) $ctrlName	string		buttonStr = StringByKey("title", S_recreation, "=",",")		// Get button title (this gives you a bunch of junk after the title too)	buttonStr = buttonStr[1,1]																// This is the current button title	string		matchStr = "01dDT"	Variable		matchLoc = StrSearch(matchStr,buttonStr,0)		Return		matchLocEnd//////////////////////////////////////////////////////////////////////////////////// Set response button mode, which is numbered zero through four as://// 	0 - not connected//// 	1 - connected//// 	d - direct (not connected)//// 	D - direct & connected//// 	T - Trash: omit from statsFunction JT_LD_setButton(ctrlName,buttonMode)	String		ctrlName	Variable		buttonMode	Variable	winNumber = str2num(ctrlName[strLen(ctrlName)-4,strLen(ctrlName)-1])	Variable	channel = str2num(ctrlName[strLen(ctrlName)-5,strLen(ctrlName)-5])	string		matchStr = "01dDT"			// Button letter in the order of buttonMode	string		colorList = ""	colorList += "0,0,0;"						// Not connected	colorList += "65535,0,0;"				// Connected	colorList += "65535,43690,0;"			// Direct (not connected)	colorList += "44253,29492,58982;"		// Direct & connected	colorList += "65535,65535,65535;"		// Trash	string		newTitle = matchStr[buttonMode]	Button		$ctrlName,win=$("JT_LD_ZoomGr_"+num2str(channel)+"_"+num2str(winNumber)),title=newTitle	Variable	colR = str2num(stringFromList(0,stringFromList(buttonMode,colorList),","))	Variable	colG = str2num(stringFromList(1,stringFromList(buttonMode,colorList),","))	Variable	colB = str2num(stringFromList(2,stringFromList(buttonMode,colorList),","))	Button		$ctrlName,win=$("JT_LD_ZoomGr_"+num2str(channel)+"_"+num2str(winNumber)),fColor=(colR,colG,colB)End////////////////////////////////////////////////////////////////////////////////////// Find the response amplitudes in the traceFunction JT_LD_FindRespAmps(responseNumber,theWave)	Variable	responseNumber	WAVE		theWave	// Parameters for zooming in	NVAR	JT_LD_xStart													// Start of first response (ms)	NVAR	JT_LD_xSpacing 												// Separation of responses (ms)	NVAR	JT_LD_nResponses 											// Number of responses to display	NVAR	JT_LD_winWidth 												// Window width (ms)	NVAR	JT_LD_xPad 													// Padding before response (ms)	NVAR	JT_LD_RespWin												// Response window (ms)	NVAR	JT_LD_latency 												// Latency to peak (ms)	NVAR	JT_LD_pulseFreq 											// Pulse frequency (Hz)	NVAR	JT_LD_nPulses 												// Number of pulse	// Waves for storing markers to the zoomed-in graphs to indicate where baselines and peaks are	Make/O/N=(0) $("JT_LD_markersY_"+num2str(responseNumber)),$("JT_LD_markersX_"+num2str(responseNumber)),$("JT_LD_markersM_"+num2str(responseNumber))	WAVE		markersY = $("JT_LD_markersY_"+num2str(responseNumber))	WAVE		markersX = $("JT_LD_markersX_"+num2str(responseNumber))	// Amp1 BASELINE	Variable	bLine1_y = mean(theWave,(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3)	Variable bLine1_x = (JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin/2)*1e-3		// Amp1 PEAK	WaveStats/Q/R=((JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency+JT_LD_RespWin)*1e-3) theWave	Variable	peak1_y = V_max	Variable	peak1_x = V_maxloc		// Add markers	markersY[numpnts(markersY)] = {bLine1_y}	markersX[numpnts(markersX)] = {bLine1_x}	markersY[numpnts(markersY)] = {peak1_y}	markersX[numpnts(markersX)] = {peak1_x}	if (JT_LD_nPulses>1)		// Amp2 PEAK		WaveStats/Q/R=(1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3,1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency+JT_LD_RespWin)*1e-3) theWave		Variable	peak2_y = V_max		Variable	peak2_x = V_maxloc			// Amp2 BASELINE		WaveStats/Q/R=(1/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin)*1e-3,peak2_x) theWave		Variable	bLine2_y = V_min		Variable bLine2_x = V_minloc		// Add markers		markersY[numpnts(markersY)] = {bLine2_y}		markersX[numpnts(markersX)] = {bLine2_x}		markersY[numpnts(markersY)] = {peak2_y}		markersX[numpnts(markersX)] = {peak2_x}	endif		if (JT_LD_nPulses>2)		// Amp3 PEAK		WaveStats/Q/R=(2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3,2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency+JT_LD_RespWin)*1e-3) theWave		Variable	peak3_y = V_max		Variable	peak3_x = V_maxloc			// Amp3 BASELINE		WaveStats/Q/R=(2/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin)*1e-3,peak3_x) theWave		Variable	bLine3_y = V_min		Variable bLine3_x = V_minloc		// Add markers		markersY[numpnts(markersY)] = {bLine3_y}		markersX[numpnts(markersX)] = {bLine3_x}		markersY[numpnts(markersY)] = {peak3_y}		markersX[numpnts(markersX)] = {peak3_x}	endif		// Max depol	WaveStats/Q/R=(0/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3,(JT_LD_nPulses-1)/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency+JT_LD_RespWin)*1e-3) theWave	Variable	maxDepol_y = V_max	Variable	maxDepol_x = V_maxloc	// Add markers	markersY[numpnts(markersY)] = {maxDepol_y}	markersX[numpnts(markersX)] = {maxDepol_x}		// Add markers to the zoomed-in graphs to indicate where baselines and peaks are	AppendToGraph $("JT_LD_markersY_"+num2str(responseNumber)) vs $("JT_LD_markersX_"+num2str(responseNumber))	ModifyGraph mode($("JT_LD_markersY_"+num2str(responseNumber)))=3,marker($("JT_LD_markersY_"+num2str(responseNumber)))=19		// Red circle	ModifyGraph rgb($("JT_LD_markersY_"+num2str(responseNumber))[numpnts(markersY)-1])=(0,0,65535)		// Last marker is special; it marks the max depol with blue diamond	ModifyGraph marker($("JT_LD_markersY_"+num2str(responseNumber))[numpnts(markersY)-1])=60		// Communicate Amp1, Amp2, and Amp3 back to the parent function	Variable/G JT_LD_Amp1 = peak1_y-bLine1_y	Variable/G JT_LD_MaxDepol = maxDepol_y-bLine1_y	Variable/G JT_LD_MaxDepolLoc = maxDepol_x*1e3 - (JT_LD_xStart+JT_LD_xSpacing*(responseNumber))	// Location of maxdepol rel to start (ms)	if (JT_LD_nPulses>1)		Variable/G JT_LD_Amp2 = peak2_y-bLine2_y	else		Variable/G JT_LD_Amp2 = 0	endif	if (JT_LD_nPulses>2)		Variable/G JT_LD_Amp3 = peak3_y-bLine3_y	else		Variable/G JT_LD_Amp3 = 0	endifEnd////////////////////////////////////////////////////////////////////////////////////// Auto y-axisFunction JT_LoadData_AutoYproc(ctrlName) : ButtonControl	String		ctrlName		// Parameters from the LoadDataPanel	WAVE		JT_LoadDataFromThisChannel		// Parameters for zooming in	NVAR		JT_LD_xStart					// Start of first response (ms)	NVAR		JT_LD_xSpacing					// Separation of responses (ms)	NVAR		JT_LD_nResponses				// Number of responses to display	NVAR		JT_LD_winWidth					// Window width (ms)	NVAR		JT_LD_xPad						// Padding before response (ms)	NVAR		JT_LD_RespWin					// Response window (ms)	NVAR		JT_LD_latency					// Latency to peak (ms)	NVAR		JT_LD_pulseFreq				// Pulse frequency (Hz)	NVAR		JT_LD_nPulses					// Number of pulse	Variable yCenter	Variable yRange	Variable yZoomOut	Variable yNewRange	Variable yMax	Variable	yMin	Variable		i,k	Variable		maxY = -Inf	Variable		doAutoY = 1		Variable Keys = GetKeyState(0)			// If user holds shift, then do Smart Y Axis on present graph	if (Keys & 2^2)		SetAxis/A=2 left		Abort	endif		ControlInfo/W=JT_LoadWavesPanel plotMeanTraceCheck	Variable	plotMeanTrace = V_Value	pauseUpdate	i = 0	do		if (JT_LoadDataFromThisChannel[i])			k = 0			do				ControlInfo/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) AutoYbutton				if (StringMatch("A",S_recreation[strsearch(S_recreation,"title",0)+7,strsearch(S_recreation,"title",0)+7]))					Button AutoYbutton,title="N",win=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))					GetAxis/Q/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left					if ((V_max-V_min)>maxY)						maxY = V_max-V_min					endif				else					Button AutoYbutton,title="A",win=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))					doAutoY = 0					if (plotMeanTrace)						WAVE	meanTrace = $("avgWave_"+num2str(i+1))						WaveStats/Q/R=((JT_LD_xStart+JT_LD_xSpacing*k-JT_LD_xPad)*1e-3,(JT_LD_xStart+JT_LD_xSpacing*k+JT_LD_winWidth-JT_LD_xPad)*1e-3) meanTrace						yCenter = (V_min+V_max)/2						yRange = V_max-V_min						yZoomOut = 1.2						yNewRange = yRange*yZoomOut						yMax = yCenter+yNewRange/2						yMin = yCenter-yNewRange/2						SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left,yMin,yMax					else						SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k))/A=2 left					endif				endif				k += 1			while(k<JT_LD_nResponses)		endif		i += 1	while(i<4)		if (doAutoY)		i = 0		do			if (JT_LoadDataFromThisChannel[i])				k = 0				do					GetAxis/Q/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left					SetAxis/W=$("JT_LD_ZoomGr_"+num2str(i+1)+"_"+num2str(k)) left,V_min,V_min+maxY					k += 1				while(k<JT_LD_nResponses)			endif			i += 1		while(i<4)	endif	resumeUpdate	End////////////////////////////////////////////////////////////////////////////////////// Show LoadData stats tableFunction JT_LoadData_StatsProc(ctrlName) : ButtonControl	String		ctrlName	Variable		channelNumber = str2num(ctrlName[11])	Variable		responseNumber = str2num(ctrlName[13,strLen(ctrlName)-1])	print "=== Stats from Channel "+num2str(channelNumber)+" ==="	JT_LoadData_doStats(ChannelNumber,responseNumber,1)	EndFunction JT_LoadData_doStats(ChannelNumber,responseNumber,showTable)	Variable		channelNumber,responseNumber,showTable		WAVE JT_LD_responseWave = $("JT_LD_responseWave"+num2str(channelNumber))	WAVE JT_LD_responseAmp1Wave = $("JT_LD_responseAmp1Wave"+num2str(channelNumber))	WAVE JT_LD_responseAmp2Wave = $("JT_LD_responseAmp2Wave"+num2str(channelNumber))	WAVE JT_LD_responseAmp3Wave = $("JT_LD_responseAmp3Wave"+num2str(channelNumber))	WAVE JT_LD_responseCV1Wave = $("JT_LD_responseCV1Wave"+num2str(channelNumber))	WAVE JT_LD_responseCV2Wave = $("JT_LD_responseCV2Wave"+num2str(channelNumber))	WAVE JT_LD_responseCV3Wave = $("JT_LD_responseCV3Wave"+num2str(channelNumber))	WAVE JT_LD_responsePPRWave = $("JT_LD_responsePPRWave"+num2str(channelNumber))	WAVE JT_LD_responseTPRWave = $("JT_LD_responseTPRWave"+num2str(channelNumber))		WAVE JT_LD_maxDepolWave = $("JT_LD_maxDepolWave"+num2str(channelNumber))	WAVE JT_LD_maxDepolLocWave = $("JT_LD_maxDepolLocWave"+num2str(channelNumber))		WAVE JT_LD_isDirectWave = $("JT_LD_isDirectWave"+num2str(channelNumber))	WAVE JT_LD_directDepWave = $("JT_LD_directDepWave"+num2str(channelNumber))	WAVE JT_LD_isTrashWave = $("JT_LD_isTrashWave"+num2str(channelNumber))	Variable nResp = sum(JT_LD_responseWave)		Make/O/N=(nResp) JT_wRespNum,JT_wAmp1,JT_wAmp2,JT_wAmp3,JT_wCV1,JT_wCV2,JT_wCV3,JT_wPPR,JT_wTPR,JT_wMaxDepol,JT_wMaxDepolLoc,JT_isDirect,JT_isDirectOnly,JT_directDep,JT_isTrash,JT_corrAmp1,JT_corrAmp2,JT_corrAmp3	JT_corrAmp1 = 0	JT_corrAmp2 = 0	Variable	n = numpnts(JT_LD_responseWave)	Variable	i,j	Variable	highLightRow = -1	i = 0	j = 0	do		if (JT_LD_responseWave[i])			JT_wRespNum[j] = i			JT_wAmp1[j] = JT_LD_responseAmp1Wave[i]			JT_wAmp2[j] = JT_LD_responseAmp2Wave[i]			JT_wAmp3[j] = JT_LD_responseAmp3Wave[i]			JT_wCV1[j] = JT_LD_responseCV1Wave[i]			JT_wCV2[j] = JT_LD_responseCV2Wave[i]			JT_wCV3[j] = JT_LD_responseCV3Wave[i]			JT_wPPR[j] = JT_LD_responsePPRWave[i]			JT_wTPR[j] = JT_LD_responseTPRWave[i]			JT_wMaxDepol[j] = JT_LD_maxDepolWave[i]			JT_wMaxDepolLoc[j] = JT_LD_maxDepolLocWave[i]			if (JT_wCV1[j]<0)				print "\t\tWARNING! Response "+num2str(i)+" has negative CV1!"			endif			if (JT_wPPR[j]<0)				print "\t\tWARNING! Response "+num2str(i)+" has negative PPR!"			endif			if (JT_wTPR[j]<0)				print "\t\tWARNING! Response "+num2str(i)+" has negative TPR!"			endif			JT_isDirect[j] = JT_LD_isDirectWave[i]			JT_directDep[j] = JT_LD_directDepWave[i]			JT_isTrash[j] = JT_LD_isTrashWave[i]			// If			// 	CV < 0.5			// 	0.75 < PPR < 1.33333			// then treat it as direct only			if (JT_isDirect[j])				JT_corrAmp1[j] = JT_wAmp1[j]-JT_directDep[j]*3.1959		// This scaling factor is from the supp fig with synaptic blockade				JT_corrAmp2[j] = JT_wAmp2[j]-JT_directDep[j]*3.1959				JT_corrAmp3[j] = JT_wAmp3[j]-JT_directDep[j]*3.1959				if ( (JT_wCV1[j]<0.5) %& (0.75<JT_wPPR[j]) %& (JT_wPPR[j] < 1.33333) )					JT_isDirectOnly[j] = 1		// Predicted as being direct only, so user is recommended not to rely on the corrected amplitude column				else					JT_isDirectOnly[j] = 0				endif			endif			if (i==responseNumber)				highLightRow = j			endif			j += 1		endif		i += 1	while(i<n)		// Convert to mV	JT_wAmp1 *= 1e3	JT_wAmp2 *= 1e3	JT_wAmp3 *= 1e3	JT_directDep *= 1e3	JT_corrAmp1 *= 1e3		JT_corrAmp2 *= 1e3	JT_corrAmp3 *= 1e3	JT_wMaxDepol *= 1e3	Variable		ScSc = PanelResolution("")/ScreenResolution	Variable		Xpos = 5	Variable		Ypos = 53	Variable		Width = 550+600	Variable		Height = 320	doWindow/K JT_LD_StatsTable	if (showTable)		Edit/K=1/W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc) JT_wRespNum,JT_wAmp1,JT_wAmp2,JT_wAmp3,JT_wCV1,JT_wCV2,JT_wCV3,JT_wPPR,JT_wTPR,JT_wMaxDepol,JT_wMaxDepolLoc,JT_isDirect,JT_isDirectOnly,JT_directDep,JT_isTrash,JT_corrAmp1,JT_corrAmp2,JT_corrAmp3 as "Stats for Channel "+num2str(channelNumber)		doWindow/C JT_LD_StatsTable		Variable sigDig = 4		ModifyTable title(JT_wRespNum)="Response #"		ModifyTable sigDigits(JT_wAmp1)=sigDig		ModifyTable title(JT_wAmp1)="Amp1 (mV)"		ModifyTable sigDigits(JT_wAmp2)=sigDig		ModifyTable title(JT_wAmp2)="Amp2 (mV)"		ModifyTable sigDigits(JT_wAmp3)=sigDig		ModifyTable title(JT_wAmp3)="Amp3 (mV)"		ModifyTable sigDigits(JT_wCV1)=sigDig		ModifyTable title(JT_wCV1)="CV1"		ModifyTable sigDigits(JT_wCV2)=sigDig		ModifyTable title(JT_wCV2)="CV2"		ModifyTable sigDigits(JT_wCV3)=sigDig		ModifyTable title(JT_wCV3)="CV3"		ModifyTable sigDigits(JT_wPPR)=sigDig		ModifyTable title(JT_wPPR)="PPR"		ModifyTable sigDigits(JT_wTPR)=sigDig		ModifyTable title(JT_wTPR)="TPR"		ModifyTable sigDigits(JT_wMaxDepol)=sigDig		ModifyTable title(JT_wMaxDepol)="MaxDep"		ModifyTable sigDigits(JT_wMaxDepolLoc)=sigDig		ModifyTable title(JT_wMaxDepolLoc)="MaxLoc"		ModifyTable sigDigits(JT_isDirect)=sigDig		ModifyTable title(JT_isDirect)="Direct?"		ModifyTable sigDigits(JT_isDirectOnly)=sigDig		ModifyTable title(JT_isDirectOnly)="Dir only?"		ModifyTable sigDigits(JT_directDep)=sigDig		ModifyTable title(JT_directDep)="Dir amp (mv)"		ModifyTable sigDigits(JT_isTrash)=sigDig		ModifyTable title(JT_isTrash)="Trash?"		ModifyTable sigDigits(JT_corrAmp1)=sigDig		ModifyTable title(JT_corrAmp1)="cAmp1 (mV)"		ModifyTable sigDigits(JT_corrAmp2)=sigDig		ModifyTable title(JT_corrAmp2)="cAmp2 (mV)"		ModifyTable sigDigits(JT_corrAmp3)=sigDig		ModifyTable title(JT_corrAmp3)="cAmp3 (mV)"				if (highLightRow!=-1)			print "\t\tHighlighting response "+num2str(responseNumber)+" in table."			ModifyTable selection=(highLightRow,0,highLightRow,17,-1,-1)		else			print "\t\tThe selected graph does not have a response."		endif				ModifyTable autosize={0,0,-1,0,0}	endif		print "\t\tConnectivity: "+num2str(sum(JT_LD_responseWave))+"/"+num2str(numpnts(JT_LD_responseWave))+" = "+num2str(sum(JT_LD_responseWave)/numpnts(JT_LD_responseWave)*100)+"%"	WaveStats/Q/Z JT_wAmp1	print "\t\tAmp1:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"	WaveStats/Q/Z JT_wAmp2	print "\t\tAmp2:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"	WaveStats/Q/Z JT_wAmp3	print "\t\tAmp3:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"	WaveStats/Q/Z JT_wCV1	print "\t\tCV1:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)	WaveStats/Q/Z JT_wCV2	print "\t\tCV2:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)	WaveStats/Q/Z JT_wCV3	print "\t\tCV3:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)	WaveStats/Q/Z JT_wPPR	print "\t\tPPR:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)	WaveStats/Q/Z JT_wTPR	print "\t\tTPR:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)	WaveStats/Q/Z JT_wMaxDepol	print "\t\tMax depol:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"	WaveStats/Q/Z JT_wMaxDepolLoc	print "\t\tMax depol latency:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" ms"		WaveStats/Q/Z JT_directDep	print "\t\tDirect depolarization amplitude in first ~2 ms:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"	Duplicate/O JT_directDep,JT_directDep2	JT_directDep2 = JT_isDirect[p] ? JT_directDep[p] : NaN	WaveStats/Q/Z JT_directDep2	print "\t\tDirect depolarization amplitude for those that are tagged as direct:\t"+num2str(V_avg)+" ± "+num2str(V_SEM)+" mV"		doWindow/H/F 		if (showTable)		DoWindow/F $("JT_LD_ZoomGr_"+num2str(channelNumber)+"_"+num2str(responseNumber))	endifEnd////////////////////////////////////////////////////////////////////////////////////// Align all sweeps in top graph to baselineFunction JT_AlignBaselineLikeMP(mode,AxisStr,x1,x2)	Variable	mode	String	AxisStr	Variable	x1	Variable	x2	String		ListOfWaves = TraceNameList("",";",1)	Variable		nItems = ItemsInList(ListOfWaves)	String		CurrWave		Variable	i	Variable	theMean	Variable	MeanOfMeans = 0	Variable	nItemsAveraged = 0		if (mode==2)		i = 0		do			CurrWave = StringFromList(i,ListOfWaves)			if (StringMatch(WhichYAxis(currWave),AxisStr))				WAVE	w = $CurrWave				MeanOfMeans += Mean(w,x1,x2)				nItemsAveraged += 1			endif			i += 1		while (i<nItems)		MeanOfMeans /= nItemsAveraged	endif	i = 0	do		CurrWave = StringFromList(i,ListOfWaves)		if (StringMatch(WhichYAxis(currWave),AxisStr))			WAVE	w = $CurrWave			theMean = Mean(w,x1,x2)			ModifyGraph offset($CurrWave)={0,MeanOfMeans-theMean}		endif		i += 1	while (i<nItems)End////////////////////////////////////////////////////////////////////////////////////// Response window checkbox proc -- DEPRECATED 10 Feb 2023////Function JT_LD_RespWinCheckProc(ctrlName,checked) : CheckBoxControl//	String	ctrlName//	Variable	checked//	//	Variable	winNumber = str2num(ctrlName[strLen(ctrlName)-4,strLen(ctrlName)-1])//	Variable channel = str2num(ctrlName[strLen(ctrlName)-5,strLen(ctrlName)-5])////	WAVE JT_LD_responseWave = $("JT_LD_responseWave")+num2str(channel)//	JT_LD_responseWave[winNumber]=checked//	JT_LD_DrawBars(winNumber,checked)//	print "Connectivity: "+num2str(sum(JT_LD_responseWave))+"/"+num2str(numpnts(JT_LD_responseWave))+" = "+num2str(sum(JT_LD_responseWave)/numpnts(JT_LD_responseWave)*100)+"%"////End////////////////////////////////////////////////////////////////////////////////////// In zoomed-in window, plot bars indicating position of response windowsFunction JT_LD_DrawBars(responseNumber,connectedFlag,directFlag,trashFlag)	Variable	responseNumber	Variable	connectedFlag	Variable	directFlag	Variable	trashFlag	// Parameters for zooming in	NVAR	JT_LD_xStart												// Start of first response (ms)	NVAR	JT_LD_xSpacing 											// Separation of responses (ms)	NVAR	JT_LD_nResponses 											// Number of responses to display	NVAR	JT_LD_winWidth 											// Window width (ms)	NVAR	JT_LD_xPad 													// Padding before response (ms)	NVAR	JT_LD_RespWin												// Response window (ms)	NVAR	JT_LD_latency 												// Latency to peak (ms)	NVAR	JT_LD_pulseFreq 											// Pulse frequency (Hz)	NVAR	JT_LD_nPulses 												// Number of pulse	SetDrawLayer/K UserBack	SetDrawLayer UserBack	Variable	n = JT_LD_nPulses	Variable	i	i = 0	do		// Baseline window		SetDrawEnv xcoord= bottom,dash= 1,fillfgc= (56797,56797,56797),linethick= 0.00		if (connectedFlag)			SetDrawEnv fillfgc=(65535,32768,32768)	// (26214,26214,26214)		endif		if (directFlag %& !connectedFlag)			SetDrawEnv fillfgc=(65535,43690,0)		endif		if (trashFlag)			SetDrawEnv fillfgc=(65535,65535,65535)		endif		DrawRect i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)-JT_LD_RespWin)*1e-3,0,i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3,1		// Peak window		SetDrawEnv xcoord= bottom,dash= 1,fillfgc= (56797,56797,56797),linethick= 0.00		if (connectedFlag)			SetDrawEnv fillfgc=(65535,32768,32768)	// (26214,26214,26214)		endif		if (directFlag %& !connectedFlag)			SetDrawEnv fillfgc=(65535,43690,0)		endif		if (trashFlag)			SetDrawEnv fillfgc=(65535,65535,65535)		endif		DrawRect i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency)*1e-3,0,i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_latency+JT_LD_RespWin)*1e-3,1		i += 1	while(i<n)	// Axes are red all around if there is a response.//	colorList += "0,0,0;"						// Not connected//	colorList += "65535,0,0;"				// Connected//	colorList += "65535,43690,0;"			// Direct (not connected)//	colorList += "44253,29492,58982;"		// Direct & connected//	colorList += "65535,65535,65535;"		// Trash	if (trashFlag)		ModifyGraph mirror=0,axThick=1,axRGB=(65535,65535,65535)	else		if ((connectedFlag) %& (directFlag))			ModifyGraph mirror=2,axThick=2,axRGB=(44253,29492,58982)		endif		if ((connectedFlag) %& (!directFlag))			ModifyGraph mirror=2,axThick=2,axRGB=(65535,0,0)		endif		if ((!connectedFlag) %& (directFlag))			ModifyGraph mirror=2,axThick=2,axRGB=(65535,43690,0)		endif		if ((!connectedFlag) %& (!directFlag))			ModifyGraph mirror=0,axThick=1,axRGB=(0,0,0)		endif	endifEnd////////////////////////////////////////////////////////////////////////////////////// In zoomed-out window, plot bars indicating position of response windowsFunction JT_LD_DrawBarsZoomedOut(responseNumber,theWinStr)	Variable	responseNumber//	Variable	connectedFlag			// In most instances, don't need to use these two flags, but keep the code for now...//	Variable	directFlag	String	theWinStr	//	connectedFlag = 1		// OVERRIDE: All bars should be black	// Parameters for zooming in	NVAR	JT_LD_xStart												// Start of first response (ms)	NVAR	JT_LD_xSpacing 											// Separation of responses (ms)	NVAR	JT_LD_nResponses 											// Number of responses to display	NVAR	JT_LD_winWidth 											// Window width (ms)	NVAR	JT_LD_xPad 													// Padding before response (ms)	NVAR	JT_LD_RespWin												// Response window (ms)	NVAR	JT_LD_latency 												// Latency to peak (ms)	NVAR	JT_LD_pulseFreq 											// Pulse frequency (Hz)	NVAR	JT_LD_nPulses 												// Number of pulse	Variable	n = JT_LD_nPulses	Variable	i	i = 0	do		SetDrawLayer/W=$(theWinStr) UserBack		// Baseline window		SetDrawEnv/W=$(theWinStr) xcoord= bottom,dash= 1,fillfgc= (56797,56797,56797),linethick= 0.00//		if (connectedFlag)			SetDrawEnv/W=$(theWinStr) fillfgc=(26214,26214,26214)//		endif		DrawRect/W=$(theWinStr) i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber)+JT_LD_RespWin)*1e-3,0,i/JT_LD_pulseFreq+(JT_LD_xStart+JT_LD_xSpacing*(responseNumber))*1e-3,1		i += 1	while(i<n)End////////////////////////////////////////////////////////////////////////////////////// Close LoadData PlotsFunction JT_LoadData_CloseProc(ctrlName) : ButtonControl	String		ctrlName	JT_LoadData_doClose()	EndFunction JT_LoadData_doClose()	DoWindow/K JT_LoadDataGr	DoWindow/K JT_LoadDataGr_1	DoWindow/K JT_LoadDataGr_2	DoWindow/K JT_LoadDataGr_3	DoWindow/K JT_LoadDataGr_4	Variable i,k	if (Exists("JT_LD_GraphList"))		SVAR		JT_LD_GraphList		JT_ArrangeGraphs5(JT_LD_GraphList)	endif	End////////////////////////////////////////////////////////////////////////////////////// LoadData Plots to FrontFunction JT_LoadData_toFrontProc(ctrlName) : ButtonControl	String		ctrlName	DoWindow/F JT_LoadDataGr	DoWindow/F JT_LoadDataGr_1	DoWindow/F JT_LoadDataGr_2	DoWindow/F JT_LoadDataGr_3	DoWindow/F JT_LoadDataGr_4	Variable i,k	if (Exists("JT_LD_GraphList"))		SVAR		JT_LD_GraphList		JT_ArrangeGraphs3(JT_LD_GraphList)	endifEnd////////////////////////////////////////////////////////////////////////////////////// Refresh LoadData panelFunction JT_LoadData_RefreshProc(ctrlName) : ButtonControl	String		ctrlName		JT_MakeLoadWavesPanel()End////////////////////////////////////////////////////////////////////////////////////// LoadData Plots to BackFunction JT_LoadData_toBackProc(ctrlName) : ButtonControl	String		ctrlName	DoWindow/B JT_LoadDataGr	DoWindow/B JT_LoadDataGr_1	DoWindow/B JT_LoadDataGr_2	DoWindow/B JT_LoadDataGr_3	DoWindow/B JT_LoadDataGr_4	Variable i,k	if (Exists("JT_LD_GraphList"))		SVAR		JT_LD_GraphList		JT_ArrangeGraphs6(JT_LD_GraphList)	endifEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Close the panelFunction JT_LoadDataClosePanelProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K JT_LoadWavesPanel	DoWindow/K JT_LD_StatsTable	JT_LoadData_CloseProc("")End//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Make a cumulative wave into a wave showing stepsFunction JT_FromCumul(w2,w1)	WAVE	w2,w1	w1 = w2[p]-w2[p-1]	w1[0] = w2[0]End/////////////////////////////////////////////////////////////////////////////////////////////////// Average across timeFunction JT_timeAverage(xWave,yWave,binSize)	WAVE		xWave	WAVE		yWave	Variable	binSize	Variable	nIn = numpnts(yWave)	Variable	nOut = Ceil(nIn/binSize)	Variable	i,j,k		Make/O/N=(nOut) $(nameOfWave(xWave)+"_bin"),$(nameOfWave(yWave)+"_bin")	Make/O/N=(nOut) $(nameOfWave(xWave)+"_binSEM"),$(nameOfWave(yWave)+"_binSEM")	WAVE	xWave_bin = $(nameOfWave(xWave)+"_bin")	WAVE	yWave_bin = $(nameOfWave(yWave)+"_bin")	WAVE	xWave_binSEM = $(nameOfWave(xWave)+"_binSEM")	WAVE	yWave_binSEM = $(nameOfWave(yWave)+"_binSEM")	xWave_bin = NaN	yWave_bin = NaN	xWave_binSEM = NaN	yWave_binSEM = NaN	do			make/O/N=(binSize) workWave1,workWave2		workWave1 = NaN		workWave2 = NaN		i = 0		do			workWave1[i] = xWave[j]			workWave2[i] = yWave[j]			j += 1			if (j>=nIn)				i = Inf			else				i += 1			endif		while(i<binSize)		WaveStats/Q workWave1		xWave_bin[k] = V_avg		xWave_binSEM[k] = V_SEM		WaveStats/Q workWave2		yWave_bin[k] = V_avg		yWave_binSEM[k] = V_SEM		k += 1	while(k<nOut)End/////////////////////////////////////////////////////////////////////////////////////////////////// Init ensemble average panelFunction JT_initEnsAvePanel()	Variable	ScSc = PanelResolution("")/ScreenResolution		Variable	WinWidth = 300	Variable	WinX = JT_GetScreenSize()-204*2-4-WinWidth	Variable	WinY = 50	Variable	WinHeight = 32	DoWindow/K JT_ensAvePanel	NewPanel /W=(WinX*ScSc,WinY*ScSc,WinX*ScSc+WinWidth,WinY*ScSc+WinHeight) as "Ensemble averager"	DoWindow/C JT_ensAvePanel		SetDrawLayer UserBack	SetDrawEnv linethick= 1,fillbgc= (1,1,1),fillfgc= (65535/3,65535,65535/3)	DrawRRect 4,2,WinWidth-4,36-8	SetDrawEnv fsize= 18,fstyle= 1,textrgb= (0,0,0)	SetDrawEnv textxjust= 1	DrawText WinWidth/2,25,"Ensemble Averager"		Variable/G	JT_ensAve_x1 = -1	Variable/G	JT_ensAve_x2 = -1	Variable	fontSize = 10	Variable	YShift = 32	Variable	ctrlWid = WinWidth-8	Variable	xSplit		SetDrawEnv fsize=fontSize,fstyle= 0,textrgb= (0,0,0),fname="Arial"	SetDrawEnv textxjust=0,textyjust=2	DrawText 4,YShift+2,"Set start and/or end to -1 to turn off normalization."	YShift += 22	xSplit = 60/100	SetVariable index1SetVar,pos={4,YShift},size={ctrlWid*xSplit,19},limits={-Inf,Inf,1},title="Normalization start:",value=root:JT_ensAve_x1,font="Arial",fSize=fontSize	SetVariable index2SetVar,pos={8+ctrlWid*xSplit,YShift},size={ctrlWid*(1-xSplit),19},limits={-Inf,Inf,1},title="end:",value=root:JT_ensAve_x2,font="Arial",fSize=fontSize	YShift += 22	xSplit = 50/100	CheckBox SDCheck,pos={4,YShift+2},size={ctrlWid*xSplit,19},title="Show SD instead of SEM ",value=0,font="Arial",fSize=fontSize	CheckBox ToEndCheck,pos={8+ctrlWid*xSplit,YShift+2},size={ctrlWid*(1-xSplit),19},title="Average to longest wave ",value=0,font="Arial",fSize=fontSize	YShift += 22	xSplit = 70/100	Button ensAveRunButton,pos={4,YShift},size={ctrlWid*xSplit-4,20},proc=JT_ensAveRunProc,title="Create the ensemble average",fColor=(65535/2,65535,65535/2),fSize=fontSize,fstyle=1,font="Arial"	Button JT_WinCloseButton,pos={8+ctrlWid*xSplit,YShift},size={ctrlWid*(1-xSplit)-4,20},proc=JT_WinCloseProc,title="Close",fSize=fontSize,font="Arial",fstyle=1	YShift += 22	MoveWindow/W=JT_ensAvePanel WinX*ScSc,WinY*ScSc,WinX*ScSc+WinWidth*ScSc,WinY*ScSc+YShift*ScSc		// Adjust panel size based on number of controls added to it...	Print "This panel averages across waves in the top window."		Print "If you need to average a single wave across time, use the JT_timeAverage() function instead."End/////////////////////////////////////////////////////////////////////////////////////////////////// Create ensemble average from top graphFunction JT_ensAveRunProc(ctrlName) : ButtonControl	String		ctrlName		NVAR		JT_ensAve_x1	NVAR		JT_ensAve_x2		Variable	SDFlag = 0	Variable	endAtMaxFlag = 0		print "--- Running Ensemble Averager ---"		ControlInfo/W=JT_ensAvePanel SDCheck	SDFlag = V_Value		ControlInfo/W=JT_ensAvePanel ToEndCheck	endAtMaxFlag = V_Value		JT_ensAverage(JT_ensAve_x1,JT_ensAve_x2,SDFlag,endAtMaxFlag)	AutoPositionWindow/M=0/R=JT_ensAveGraph JT_ensAvePanel	print "--- Done ---"	End	Function JT_ensAverage(x1,x2,SDFlag,endAtMaxFlag)	Variable	x1,x2	Variable	SDFlag	Variable	endAtMaxFlag		if (SDFlag)		print "Errorbars denote standard deviation."	else		print "Errorbars denote standard error of the mean."	endif		if (endAtMaxFlag)		print "Averaging ends at the last data point of the longest wave."	else		print "Averaging ends at the last data point of the shortest wave."	endif		Variable	normFlag = 0		if ((x1>=0) %& (x2>=0))		Print "Normalizing to 100%."		normFlag = 1		if (x1>x2)		// Ensure x2=>x1			Print "Swapping x2 and x1 because x2<x1."			Variable	tempVar = x1			x2 = x1			x1 = tempVar		endif	endif	DoWindow/K JT_ensAveGraph	// Figure out wave lengths	String		traceList =  wavelist("*",";","WIN:")	String		targetWin = WinName(0,3)	String		currTrace = ""	Variable	n = ItemsInList(traceList)	print "Found "+num2str(n)+" traces in window \""+targetWin+"\"."	Variable	nMax = -Inf	Variable	nMin = Inf	String		maxWaveName = ""	String		minWaveName = ""	Variable	i,j	i = 0	do		currTrace = StringFromList(i,traceList)		WAVE	w = $currTrace		if (nMax<numpnts(w))			nMax = numpnts(w)			maxWaveName = currTrace		endif		if (nMin>numpnts(w))			nMin = numpnts(w)			minWaveName = currTrace		endif		i += 1	while(i<n)	print "\tLargest number of points was found in wave \""+maxWaveName+"\": "+num2str(nMax)	print "\tFewest number of points was found in wave \""+minWaveName+"\": "+num2str(nMin)		if (nMin==0)		print minWaveName+" has zero data points in it. We can't work with that."		Abort minWaveName+" has zero data points in it. We can't work with that."	endif		// Find baseline means, to use with normalization below	if (normFlag)		Variable	nAvePoints = x2-x1+1		Make/O/N=(n) JT_normW		i = 0		do			Make/O/N=(0) tempW			currTrace = StringFromList(i,traceList)			WAVE	w = $currTrace			j = 0			do				if (j+x1<=numpnts(w)-1)					tempW[numpnts(tempW)] = {w[j+x1]}				else					print "Fatal error: Index out of bounds for \""+currTrace+"\"."					print "\tTried to access data point "+num2str(j+x1)+" even though there are only "+num2str(numpnts(w))+" points in this wave."					print "\tYou probably have to set the indices used to normalize to smaller values."					Abort "Fatal error: Index out of bounds for \""+currTrace+"\". See history window for more info."				endif				j += 1			while(j<nAvePoints)			WaveStats/Q tempW			if (V_npnts==0)				print "Fatal error: No data points in \""+currTrace+"\" could be used for normalizing."				print "\tDoes this wave contain NaNs within the normalization region of interest?"				Abort "Fatal error: No data points in \""+currTrace+"\" could be used for normalizing. See history window for more info."			endif			JT_normW[i] = V_avg			i += 1		while(i<n)	endif	// Create the actual ensemble average	Variable	averageUntilVal = nMin						// Average to the end of  the shortest wave	if (endAtMaxFlag)		averageUntilVal = nMax								// Average to the end of the longest wave	endif	Make/O/N=(averageUntilVal) JT_wM,JT_wS	j = 0	do		Make/O/N=(n) tempW		tempW = NaN		i = 0		do			currTrace = StringFromList(i,traceList)			WAVE	w = $currTrace			if (j<numpnts(w))								// This is needed when averaging to the end of the longest wave				if (normFlag)					tempW[i] = w[j]/JT_normW[i]*100				else					tempW[i] = w[j]				endif			endif			i += 1		while(i<n)		WaveStats/Q tempW		JT_wM[j] = V_avg		if (SDFlag)			JT_wS[j] = V_SDev		else			JT_wS[j] = V_SEM		endif		j += 1	while(j<averageUntilVal)		// Display results	DoWindow/K JT_ensAveGraph	Display JT_wM as "Ensemble average from "+targetWin	DoWindow/C JT_ensAveGraph	ModifyGraph mode=4,marker=8,opaque=1	ErrorBars JT_wM Y,wave=(JT_wS,JT_wS)	ModifyGraph RGB=(16385,28398,65535)	AutoPositionWindow/M=1/R=$(targetWin) JT_ensAveGraph	if (normFlag)		SetDrawLayer UserBack		SetDrawEnv xcoord= bottom,dash= 11		DrawLine x1,0,x1,1		SetDrawEnv xcoord= bottom,dash= 11		DrawLine x2,0,x2,1		SetDrawEnv ycoord= left,dash= 11		DrawLine 0,100,1,100		print "Verification: Average of ensemble wave across normalization period: "+num2str(Mean(JT_wM,x1,x2))+"%."	endif	String/G	JT_newNameStr = "<enter name here>"	Variable	fontSize = 10	Variable	yPos = 2	Variable	xPos = 8	Variable	xStep	ControlBar 24	xStep = 50	Button JT_WinCloseButton,pos={xPos,yPos},size={xStep,20},proc=JT_WinCloseProc,title="Close",fSize=fontSize,font="Arial",fstyle=1	xPos += xStep+8	xStep = 150	SetVariable newNameSetVar,pos={xPos,yPos+4},size={xStep,20},title="Name:",value=root:JT_newNameStr,font="Arial",fstyle=1	xPos += xStep+8	xStep = 80	Button dupliEnsButton,pos={xPos,yPos},size={xStep,20},proc=JT_dupliEnsProc,title="Duplicate",fSize=fontSize,font="Arial",fstyle=1	xPos += xStep+8	GetAxis/Q/W=$(targetWin) bottom	SetAxis/W=JT_ensAveGraph bottom,V_min,V_maxEnd/////////////////////////////////////////////////////////////////////////////////////////////////// Duplicate ensemble averageFunction JT_dupliEnsProc(ctrlName) : ButtonControl	String		ctrlName		NVAR		JT_ensAve_x1	NVAR		JT_ensAve_x2	Variable	normFlag = 0	if ((JT_ensAve_x1>=0) %& (JT_ensAve_x2>=0))		Print "Normalizing to 100%."		normFlag = 1	endif	String	defaultStr = "<enter name here>"	SVAR	JT_newNameStr		if (StringMatch(JT_newNameStr,defaultStr))		Abort "You have to enter a valid name first!"	endif		String	UsefulNameStr = JT_ZapGremlins(JT_newNameStr)	Print "Duplicating with name \""+JT_newNameStr+"\"."		Duplicate/O JT_wS,$(JT_newNameStr+"_s")	Duplicate/O JT_wM,$(JT_newNameStr+"_m")		DoWindow/K $("ensAve_"+JT_newNameStr)	Display $(JT_newNameStr+"_m") as JT_newNameStr	DoWindow/C $("ensAve_"+JT_newNameStr)	ModifyGraph mode=4,marker=8,opaque=1	ErrorBars $(JT_newNameStr+"_m") Y,wave=($(JT_newNameStr+"_s"),$(JT_newNameStr+"_s"))	ModifyGraph RGB=(16385,28398,65535)	AutoPositionWindow/M=1/R=JT_ensAveGraph $("ensAve_"+JT_newNameStr)	if (normFlag)		SetDrawLayer UserBack		SetDrawEnv xcoord= bottom,dash= 11		DrawLine JT_ensAve_x1,0,JT_ensAve_x1,1		SetDrawEnv xcoord= bottom,dash= 11		DrawLine JT_ensAve_x2,0,JT_ensAve_x2,1		SetDrawEnv ycoord= left,dash= 11		DrawLine 0,100,1,100	endif	Legend/C/N=text0/J "\\s("+JT_newNameStr+"_m"+") "+JT_newNameStr	JT_AddCloseButton()	GetAxis/Q/W=JT_ensAveGraph bottom	SetAxis/W=$("ensAve_"+JT_newNameStr) bottom,V_min,V_maxEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Add a close button to top graphFunction JT_AddCloseButton()	Button JT_WinCloseButton,pos={0,1},size={18,18},proc=JT_WinCloseProc,title="×",fSize=10,font="Arial"EndFunction JT_WinCloseProc(ctrlName) : ButtonControl	String		ctrlName	String		topWin = StringFromList(0,WinList("*",";",""))	DoWindow/K $topWinEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Add a resize button to top graphFunction JT_AddResizeButton()	Variable	yPos = 1						// Automatically adapt to the possible existence of the above CloseButton	controlInfo JT_WinCloseButton	if (V_flag)		yPos += 20	endif	Button JT_WinResizeButton,pos={0,yPos},size={18,18},proc=JT_WinResizeProc,title="R",fSize=10,font="Arial"EndFunction JT_WinResizeProc(ctrlName) : ButtonControl	String		ctrlName	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable	x1,x2,y1,y2	Variable	sx1,sx2,sy1,sy2	Variable 	Keys = GetKeyState(0)	Variable		forceStore = 0	Variable		halfMaximized = 0	if (Keys & 2^0)			// Command (control)		forceStore = 1	endif	if (Keys & 2^2)			// Shift		halfMaximized = 1	endif		if ( (forceStore) %& (halfMaximized))		print "Shift key = half-max window size"		print "Command key (control key on Windows) = store current window position"		Abort "It does not make sense to press both these keys at the same time. See history window for info..."	endif	String		topWin = StringFromList(0,WinList("*",";",""))	GetWindow $topWin, wsize	x1 = V_left/ScSc	x2 = V_right/ScSc	y1 = V_top/ScSc	y2 = V_bottom/ScSc	if (Exists("JTpos_"+topWin))		SVAR posStr = $("JTpos_"+topWin)		sx1 = str2num(StringFromList(0,posStr))		sx2 = str2num(StringFromList(1,posStr))		sy1 = str2num(StringFromList(2,posStr))		sy2 = str2num(StringFromList(3,posStr))		if (forceStore)			print "Stored current window position."			posStr = ""			posStr += num2str(x1)+";"			posStr += num2str(x2)+";"			posStr += num2str(y1)+";"			posStr += num2str(y2)+";"		else			// If in stored position, maximize the window			if ( (x1==sx1) %& (x2==sx2) %& (y1==sy1) %& (y2==sy2) )				print "Maximizing window."				if (halfMaximized)					JT_ArrangeGraphs2(topWin,2,2)				else					JT_ArrangeGraphs2(topWin,1,1)				endif			else				// otherwise resize to the stored position				print "Resizing window back to stored size & position."			 	MoveWindow/W=$(topWin) sx1*ScSc,sy1*ScSc,sx2*ScSc,sy2*ScSc			endif		endif	else		// If not previously stored, store & then maximize		String/G $("JTpos_"+topWin)		SVAR posStr = $("JTpos_"+topWin)		posStr = ""		posStr += num2str(x1)+";"		posStr += num2str(x2)+";"		posStr += num2str(y1)+";"		posStr += num2str(y2)+";"		if (forceStore)			print "Stored current window position."		else			print "Maximizing window."			if (halfMaximized)				JT_ArrangeGraphs2(topWin,2,2)			else				JT_ArrangeGraphs2(topWin,1,1)			endif		endif	endifEnd///////////////////////////////////////////////////////////////////////////////////// Dump ScanImage comments in a notebook windowFunction JT_LoadTIFFheader()		if (!(Str2Num(StringByKey("IGORVERS",IgorInfo(0))) > 5.02))		Abort("Only works with Igor PRO versions 5.03 and higher.")	endif	string		RAT_Str		String		ImageFile	String		FileNameOnly		Variable	dumvar		String	saveDataFolder = GetDataFolder(1) 	NewDataFolder/O/S root:temp		Open/D/R/T=".tif"/M="Select TIFF file whose header you wish to load." dumvar	ImageFile = S_fileName	FileNameOnly = StringFromList(ItemsInList(ImageFile,":")-1,ImageFile,":")	if (Str2Num(StringByKey("IGORVERS",IgorInfo(0))) > 5.02)		// Only Igor 5.03 and above can use the /rat flag (Read All Tags)		// ScanImage uses the TIFF comments field to store its data field		Execute "ImageLoad/Q/Z/BIGT=1/LTMD/T=tiff/C=-1 /O/N='AllImageRAW' \""+ImageFile+"\""			// Must do Execute to allow this proc to run on Igor v5.02 and lower, or else /RAT flag won't permit compilation		WAVE/T	T_Tags = root:temp:Tag0:T_Tags		if (1)												// Old TIFF header style pertains to ScIm v3.7 and lower; Modern is ScIm 2015 and up (I think!)			RAT_Str = T_Tags[12]		else			RAT_Str = T_Tags[JT_FindIMAGEDESCRIPTION(T_Tags)][4]		endif		KillDataFolder/Z root:Tag0											// Avoid having these data folders build up as more images are loaded		KillDataFolder/Z root:Tag1	else		Abort "You need to upgrade to Igor v5.03 or higher."	endif		DoWindow/K ScanImageComments	NewNotebook/N=ScanImageComments/F=1/V=1/W=(500,50,1022,512) as "ScanImage Comments"//+HeaderLine	Notebook ScanImageComments defaultTab=36, statusWidth=238, pageMargins={72,72,72,72}	Notebook ScanImageComments showRuler=0, rulerUnits=1, updating={1, 216000}	Notebook ScanImageComments newRuler=Title, justification=0, margins={0,0,538}, spacing={0,0,0}, tabs={}, rulerDefaults={"Arial",18,0,(0,0,0)}	Notebook ScanImageComments newRuler=Normal, justification=0, margins={0,0,468}, spacing={0,0,0}, tabs={16,32,400+3*8192,450+8192*2}, rulerDefaults={"Arial",12,0,(0,0,0)}	Notebook ScanImageComments ruler=Normal,text=(RAT_Str+"\r")	Notebook ScanImageComments selection={startOfFile, startOfFile}	// Show start of notebook	Notebook ScanImageComments ruler=Title,textRGB=(0,0,65535), text="\rScanImage Comments for "+FileNameOnly+"\r",textRGB=(0,0,0)	Notebook ScanImageComments ruler=Normal,text=("\r")		KillDataFolder root:temp	SetDataFolder saveDataFolderEnd/////////////////////////////////////////////////////////////////// Find IMAGEDESCRIPTION tag from ScanImageFunction JT_FindIMAGEDESCRIPTION(theWave)	WAVE/T	theWave	Variable	theIndex = -1		Variable	i = 0	Variable	nRows = DimSize(theWave,0)		do		if (StringMatch("IMAGEDESCRIPTION",theWave[i][1]))			theIndex = i			i = Inf		endif		i += 1	while (i<nRows)	Return	theIndex	end////////////////////////////////////////////////////////////////////////////////////// Wait specified number of ticks, to pause executionFunction JT_WaitNTicks(howMany)	Variable	howMany	Variable	untilTicks = ticks+howMany		do	while(ticks<untilTicks)End////////////////////////////////////////////////////////////////////////////////////// Make gamma-corrected LUTFunction JT_makeGammaCorrectedLUT(theGamma,theColorTab)	Variable		theGamma	String		theColorTab	ColorTab2Wave $(theColorTab)			// e.g. BlueHot256	WAVE		M_colors		JT_GammaCorrectedLUT(theGamma,M_colors)	End	Function JT_GammaCorrectedLUT(theGamma,theColorWave)	Variable		theGamma	WAVE			theColorWave	Variable	nColorsIn = DimSize(theColorWave,0)	Variable	nColorsOut = 2^12	Make/O/N=(nColorsOut,3) JT_LUT	Variable	i,j	i = 0	do		j = floor( (i/nColorsOut)^(theGamma)*nColorsIn )		JT_LUT[i][0] = theColorWave[j][0]		JT_LUT[i][1] = theColorWave[j][1]		JT_LUT[i][2] = theColorWave[j][2]		i += 1	while(i<nColorsOut)	if (Exists("JT_gammaWaveName"))		// ensure that this code can be called even if JT_gammaWaveName has not been defined		SVAR	JT_gammaWaveName		Duplicate/O JT_LUT,$(JT_gammaWaveName)	endifEndFunction JT_gammaCorrectionPanel()	Variable		ScSc = PanelResolution("")/ScreenResolution				// Screen resolution		Variable		xPos = 150	Variable		yPos = 60	Variable		Width = 260	Variable		Height = 32		Variable		xMargin = 4	Variable		x = 4	Variable		y = 4		Variable		xSkip	Variable		ySkip = 26		Variable		bHeight = 21		Variable		fontSize = 12	Variable/G	JT_gamma = 0.8	String/G		JT_gammaWaveName = "LUT_name"	DoWindow/K gammaCorrectionPanel	NewPanel/K=1/W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc) as "Gamma correction"	DoWindow/C gammaCorrectionPanel	SetDrawLayer UserBack	SetDrawEnv fsize= 14,fstyle= 1+4,textxjust= 1,textyjust= 2,fname="Arial"	DrawText Width/2,6,"Gamma Correction Panel"	y += ySkip		xSkip = floor((Width-xMargin*1)/1)	x = xMargin	PopupMenu whichLUTpopup title="Choose LUT",pos={x,y+2},size={xSkip-4,bHeight},bodyWidth=(xSkip-4)*0.7,mode=3,value="*COLORTABLEPOP*",fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*2)/1)	x = xMargin	SetVariable GammaSetVar,pos={x,y+3},size={xSkip,bHeight},title="Gamma",value=JT_gamma,limits={0,Inf,0.1},fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*2)/1)	x = xMargin	SetVariable GammaWaveNameSetVar,pos={x,y+3},size={xSkip,bHeight},title="LUT wave name",value=JT_gammaWaveName,fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*1)/1)	x = xMargin	Button MakeGammaButton,pos={x,y},size={xSkip,bHeight},title="Make gamma-corrected LUT",Proc=JT_makeGammaLUT,fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	Height = y+4	MoveWindow/W=gammaCorrectionPanel xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc		// Adjust panel size based on number of controls added to it...EndFunction JT_makeGammaLUT(ctrlName) : ButtonControl	String ctrlName	NVAR	JT_gamma	SVAR	JT_gammaWaveName		ControlInfo/W=gammaCorrectionPanel whichLUTpopup		string	theColorTab = StringFromList(V_Value-1,CTabList())		print "Gamma-correcting \""+theColorTab+"\" using gamma "+num2str(JT_gamma)+" and giving this new LUT the name \""+JT_gammaWaveName+"\"."		print "\tIf you want to gamma-correct a non-standard color table wave, then execute:"	print "\tJT_GammaCorrectedLUT(JT_gamma,EnterColorWaveNameHere)"	JT_makeGammaCorrectedLUT(JT_gamma,theColorTab)		End